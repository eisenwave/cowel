\h3(id="code"){Code and syntax highlighting}

COWEL uses
\ref("https://github.com/Eisenwave/ulight"){µlight}
for syntax highlighting.
While the set of supported language is relatively small,
the highlighter is ultra-light, extremely fast, and
deals with modern C++ features correctly.

\h4(id="dir-code"){\cowdoc_dir{code} \c{mdash} Inline code}

The \cowdoc_dir{code} directive produced syntax-highlighted text in code font.

\dl{
  \dt{Arguments}
  \dd{
    \ul{
      \li{
        \cowdoc_attr{lang} (plaintext) \c{mdash} the syntax highlighting language.
      }
      \li{
        \cowdoc_attr{nested} (true/false) \c{mdash} whether to omit \cowdoc_html{<code>} tags.
      }
    }
  }

  \dt{Input content}
  \dd{
  The input to a \cowdoc_dir{code} directive is a plaintext context.
  However, there are special rules for formatting directives
  and pure plaintext directives (see below).
  }

  \dt{HTML output}
  \dd{
  In an HTML context, the \cowdoc_dir{code} takes the input source code,
  applies syntax highlighting,
  and outputs the result surrounded by \cowdoc_html{<code>...</code>}.
  }

  \dt{Plaintext output}
  \dd{
  In a plaintext context, \cowdoc_dir{code} simply outputs the input source code.
  }

  \dt{Display style}
  \dd{Inline}
}

\Bex{
COWEL markup:
\cowblock{
\\code(cpp){123}
}
This applies C++ syntax highlighting, and generates HTML.
The \cowdoc_html{<h->} tags are an implementation detail and may be subject to change.
\htmlblock{
<code><h- data-h=num>123</h-></code>
}
}

\h5{Manual nested highlighting}

The \tt{nested} parameter is a plaintext context,
which accepts either \tt{true} or \tt{false}, where \tt{false} is the default.
When enabled, the surrounding \cowdoc_html{<code>} tags are omitted,
which makes it suitable for nesting languages
within other \cowdoc_dir{code} or \cowdoc_dir{codeblock} directives.

\Bex{
You can nest JSON inside of a C++ string literal as follows:
\cowblock{\unprocessed{
Call: \code(cpp){out.write_json("\code(json,nested=true){{"x":123,"y":true,"z":null}}")}
}}
This renders as follows:
\Bindent{
Call: \code(cpp){out.write_json("\code(json,nested=true){{"x":123,"y":true,"z":null}}")}
}
}

Note that by default,
you may often not even notice a visual difference between using the \tt{nested}
parameter and not using it.
However, the difference would be obvious once you want to style \cowdoc_html{<code>} elements
to have borders, background color, padding, and other such styling features.
\tt{nested=true} directly emits the highlighting HTML elements,
which is more composable.

\h5{Further advice on highlighting}

\Btip{
Writing \cowdoc_dir{code} directives directly is often too tedious,
so you'll likely want to define a macro to make this easier:
\cowblock{
\\: Defines a \\js directive that can be used in place of \\code(js) from now on:
\\macro(\\js){\\code(js){\\put}}
Let's highlight \\js{var} in JavaScript.
}
}

\h4(id="dir-codeblock"){\cowdoc_dir{codeblock} \c{mdash} Code blocks}

The \cowdoc_dir{codeblock} directive works exactly like \cowdoc_dir{code},
but it is a block directive, not an inline directive.

Additionally, code blocks render using borders and a dark background by default.
This can be controlled using the \tt{borders}.

\Bex{
\cowblock{
\\codeblock(js){
// Borders enabled
let x = 0;
}
\\codeblock(js, borders = false){
// Borders disabled
let x = 0;
}
}
This renders as:
\codeblock(js){
// Borders enabled
let x = 0;
}
\codeblock(js, borders = false){
// Borders disabled
let x = 0;
}
}

\h4(id="dir-hl"){\cowdoc_dir{hl} \c{mdash} Syntax highlight override}

The \cowdoc_dir{hl} directive forces certain syntax highlighting to be applied to some text;
it is a manual override for when automatic syntax highlighting is insufficient or broken.
It displays as inline content and wraps its content (which is an HTML context)
in the appropriate syntax highlighting tags.

It has a single \tt{name} argument, which is the µlight \dfn{long name} for a highlight type.
You can obtain a list of possible long names at
\ref("https://github.com/Eisenwave/ulight/blob/main/include/ulight/ulight.h"){\tt{ulight.h}}
from the definition of \code(cpp){enum ulight_highlight_type}.
The long name is the enumerator name without the \tt{ULIGHT_HL} prefix,
all lowercase, and with hyphens instead of underscores.

\Bex{
It is possible to mix automatic syntax highlighting with manual overrides:
\cowblock{\literally{
\: _Int128 is manually highlighted as a type keyword,
\: and x is automatically highlighted as an identifier.
\code(c){\hl("keyword-type"){_Int128} x}
}}
This generates the HTML (subject to change):
\htmlblock{
<code><h- data=h=kw_type>_Int128</h-> <h- data-h=id>x</h-></code>
}
It renders as \code(c){\cowel_highlight_as("keyword-type"){_Int128} x}.
}

\Bnote{
While it is also possible to produce the highlighting tags using
\cowdoc_c{\\html-h-(data-h=kw_type){_Int128}},
the "short names" (\cowdoc_c{kw_type}) are not stable, i.e. they are more likely to change.
Only µlight long names should be used directly.
}

\h4(id="dir-pre"){\cowdoc_dir{pre} \c{mdash} Preformatted blocks}

The \cowdoc_dir{pre} directive contains pre-formatted content.
It can be used to contain code, however, there is no syntax highlighting in a \cowdoc_dir{pre} block.

\Bex{
COWEL markup:
\cowblock{
\\pre{
Hello, world!
=============
    a b c
}
}
This renders as:
\pre{
Hello, world!
=============
    a b c
}
}

\Btodo{
Unlike \cowdoc_dir{codeblock}, \cowdoc_dir{pre} currently does not support the \tt{borders=no} option.
This will be added in the future.
}

