\h2{New directives}

Find below a list of builtin directives.
That is, directives that you can always use
because they are "built into the language".

\Bnote{
These builtin directives should rarely be used directly,
but through macro packages which utilize them.

Even if one wanted to use them,
builtin directive have long names which make them impractical for direct use in markup.
However, those long names are self-document, unambiguous,
and guaranteed not to collide with any user directives.
}

\h3{Common principles}

There are a few common principles,
which all builtin directives have in common:

\ul{
  \li{
    Unless otherwise stated,
    arguments to builtin directives are processed using the
    text-only policy (\ref("#contexts-and-output")).
  }
  \li{
    Arguments to builtin directives
    use the usual argument matching (\ref("#usual-argument-matching")).
  }
  \li{
    Whenever content or arguments are said to be ignored,
    a warning is emitted when content or arguments are provided by the user, respectively.
  }
}

\h4{Parameter notation}

While COWEL does not yet support a syntax for defining directives with parameters
of a specific type, this documentation does for the builtin directives.
This notation consists of
\ul{
  \li{the directive name,}
  \li{
    a list of parameters in parentheses,
    consisting of the parameter name and
    the parameter \gterm{type} (\ref("#types-intro")),
    separated by '\tt{:}'
    and optionally followed by '\tt{=}' and a \dfn{default value}, and
  }
  \li{
    optionally,
    the symbol \tt{{...}} to indicate that the directive accepts content.
  }
  \li{
    the result type of the directive,
    separated by '\tt{:}'
  }
}

\Bex{
The description of \cowdoc_dir{cowel_html_element} looks as follows:
\pre{
\cowel_highlight_as("markup-tag"){cowel_html_element}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str},
  \cowel_highlight_as("markup-attr"){attr}: \cowel_highlight_as("keyword-type"){lazy(group pack named string)?},
){...}: \cowel_highlight_as("keyword-type"){block}
}

Or equivalently:
\pre{
\cowel_highlight_as("markup-tag"){cowel_html_element}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){string},
  \cowel_highlight_as("markup-attr"){attr}: \cowel_highlight_as("keyword-type"){lazy(group(pack(named(string))))?},
){...}: \cowel_highlight_as("keyword-type"){block}
}

This describes that \cowdoc_dir{cowel_html_element} can be invoked as follows,
among various options:
\cowblock{\literally{
\cowel_html_element(name = div, attr = (id = abc))
}}

\tt{div} matches the \cowdoc_attr{name} parameter,
and the content \tt{div} is treated as a \tt{string} value.

\cowdoc_c{\cowel_highlight_phantom{\\d}(id = abc)}
matches the \cowdoc_attr{attr} parameter,
and within that group,
there is a single-element \tt{pack} of \tt{named} arguments
of type \tt{string} with \tt{lazy} processing.
\tt{lazy} processing implies that even if we were to reverse the order of
\cowdoc_attr{name} and \cowdoc_attr{attr},
\cowdoc_attr{name} would still be processed first.
}

\h4{Usual argument matching}

The \dfn{usual argument matching} allows matching positional and named arguments
to parameters of directives.
An error is raised if positional and named arguments are mixed,
unless all positional arguments appear contiguously at the start of the argument list.

\Bex{
\cowblock{\literally{
\: OK, two positional arguments
\cowel_html_element(div, (id = abc))
\: OK, two named arguments
\cowel_html_element(name = div, attr = (id = abc))
\: OK, all positional arguments appear at the start
\cowel_html_element(name = div, (id = abc))
\: error: positional argument following named arguments
\cowel_html_element(name = div, (id = abc))
}}
}

The usual argument matching is performed as follows:

\ol{
  \li{
    Positional arguments match parameters in the same order.
    An error is raised if there are more positional arguments than parameters.
  }
  \li{
    The following named arguments match parameters with the same name.
    An error is raised if a named argument does not match any parameter.
  }
  \li{
    If any parameter has not been matched by an argument,
    the parameter is matched by its default argument value if there is one,
    otherwise, if it has \tt{optional} type, it is matched by nothing, and
    otherwise an error is raised.
  }
}

\Bex{
Let \cowdoc_dir{d} be a directive with parameters
\cowdoc_attr{x}, \cowdoc_attr{y}, and \cowdoc_attr{z}:
\cowblock{\literally{
\: In each of these calls,
\: a, b, and c match x, y, and z, respectively:

\d(z = c, y = b, x = a)  \: OK, all named arguments
\d(a, b, c)              \: OK, all positional arguments
\d(a, z = c, y = b)      \: OK, positional arguments followed by named arguments
}}
}

\Bnote{
The usual argument matching is essentially identical to function calls in Kotlin,
but more restrictive when it comes to mixing positional and named arguments.
}

\h3(id="new-character-utilities"){Character utilities}

It is quite common that a text document should include special characters.
While COWEL is built on UTF-8 and in theory,
one could just write the character directly into the source code,
not every text editor handles special characters well,
not to mention that some characters are invisible when rendered.

For portability and convenience
COWEL has builtin directives for generating and querying characters.

\h4(
  id = "dir-cowel_char_by_entity"
){\cowdoc_dir{cowel_char_by_entity} \c{mdash} Character by HTML character reference}

\pre{
\cowel_highlight_as("markup-tag"){cowel_char_by_entity}(\cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){str}
}

The \cowdoc_dir{cowel_char_by_entity} directive takes the name of a character
and outputs the respective code points as text.
\cowdoc_attr{name} consists of an HTML entity
without the leading '\tt{&}' and trailing '\tt{;}'.

\Bex{
The '\tt{&}' character can be produced in a number of ways:
\ul{
    \li{Literally '\tt{&}' in text}
    \li{\cowdoc_c{\\cowel_char_by_entity("amp")} (like \cowdoc_html{&amp;}, named character reference)}
    \li{\cowdoc_c{\\cowel_char_by_entity("#38")} (like \cowdoc_html{&38;}, decimal character reference)}
    \li{\cowdoc_c{\\cowel_char_by_entity("#x26")} (like \cowdoc_html{&x26;}, hexadecimal character reference)}
}
}

\h4(
  id = "dir-cowel_char_by_name"
){\cowdoc_dir{cowel_char_by_name} \c{mdash} Character by Unicode name}

\pre{
\cowel_highlight_as("markup-tag"){cowel_char_by_name}(\cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){str}
}

The input to a \cowdoc_dir{cowel_char_by_num} directive is a \cowdoc_type{str} which should be a
\ref("https://www.unicode.org/reports/tr34/#Names"){Unicode name}
for a code point or one of its name aliases (of any category).

An error is raised if the given name is not the name of a code point
or an alias thereof.

\Bex{
\cowdoc_c{\\cowel_char_by_name("DIGIT ZERO")} generates
'\tt{\cowel_char_by_name("DIGIT ZERO")}', which is U+0030 DIGIT ZERO.
Case matters, i.e. \cowdoc_c{\\cowel_char_by_name("digit zero")}
raises an error,
and so do any trailing spaces or duplicate spaces in the input.
In other words, an exact character sequence is expected.
}

\h4(
  id = "dir-cowel_char_by_num"
){\cowdoc_dir{cowel_char_by_num} \c{mdash} Character by code point number}

\pre{
\cowel_highlight_as("markup-tag"){cowel_char_by_num}(\cowel_highlight_as("markup-attr"){num}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){str}
}

The input to a \cowdoc_dir{cowel_char_by_num} directive is a \cowdoc_type{str}
which should be a sequence of hexadecimal numbers
specifying a \ref("https://infra.spec.whatwg.org/#scalar-value"){Unicode scalar value};
that is, a code point which UTF-8 permits to be encoded.
All arguments are ignored.

\Bex{
\cowdoc_c{\\cowel_char_by_num(0x30)} generates
'\tt{\cowel_char_by_num(0x30)}', which is U+0030 DIGIT ZERO.
}

\Btip{
Use of \cowdoc_dir{cowel_char_by_name} can lead to much more descriptive,
human-friendly code, compared to \cowdoc_dir{cowel_char_by_num}.

The main issue with \cowdoc_dir{cowel_char_by_num} is
that it is very non-descriptive in source code.
It simply contains a handful of digits,
and unless the reader is a Unicode expert who happens to know that sequence,
they cannot easily tell what the purpose of the character is.
}

\h4(
  id="dir-cowel_char_get_num"
){\cowdoc_dir{cowel_char_get_num} \c{mdash} Get digits of character}

\pre{
\cowel_highlight_as("markup-tag"){cowel_char_get_num}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){int}
}

The \cowdoc_dir{cowel_char_get_num} directive is essentially the
inverse of the \cowdoc_dir{cowel_char_by_num} directive.
It returns the numeric value of the first input code point in \cowdoc_attr{x}.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_char_get_num("j")
U+\cowel_str_to_upper(cowel_to_str(cowel_char_get_num("j"), base=16, zpad=4))
}}
Generated HTML:
\htmlblock{
\cowel_char_get_num("j")
U+\cowel_str_to_upper(cowel_to_str(cowel_char_get_num("j"), base=16, zpad=4))
}
Note that U+006A is the usual way in which Unicode code points are represented.
That is, \tt{U+}, followed by at least four uppercase hexadecimal digits.
It is also possible to define a macro if we need this frequently:
\cowblock{\literally{
\cowel_macro(code_point){\
U+\cowel_str_to_upper(cowel_to_str(cowel_char_get_num(...), base=16, zpad=4))}
\code_point(j)
}}
}

\Bug{
If more than one code point is provided,
some input is discarded:
\cowblock{
\\cowel_char_get_num(abc)
}
This renders as
\Bindent{
\cowel_char_get_num(a)
}
... which corresponds to '\tt{a}',
whereas '\tt{b}' and '\tt{c}' are discarded.
}

\h3{HTML utilities}

\h4(
  id="dir-cowel_html_element"
){\cowdoc_dir{cowel_html_element} \c{mdash} HTML element}

\pre{
\cowel_highlight_as("markup-tag"){cowel_html_element}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){string},
  \cowel_highlight_as("markup-attr"){attr}: \cowel_highlight_as("keyword-type"){lazy(group pack named string)?},
){...}: \cowel_highlight_as("keyword-type"){block}
}

The \cowdoc_dir{cowel_html_element} directive generates content,
surrounded in HTML opening and closing HTML tags.
That is, it

\ul{
  \li{
    writes an opening tag,
    where any named arguments are converted to HTML attributes,
  }
  \li{
    feeds the provided content into the current content policy, and then
  }
  \li{
    writes a closing tag.
  }
}

The name of the HTML element is contained in the \cowdoc_attr{name} parameter,
and the attributes within the HTML element
are contained within the \cowdoc_attr{attr} parameter.

\Bex{
COWEL markup:
\cowblock{\literally{
This is \cowel_html_element(span, (id = abc)){a span}.
}}
Generated HTML:
\htmlblock{
This is <span id=abc>a span</span>.
}
}

A \cowdoc_dir{cowel_html_element} directive produces an error if the given
tag name is not a valid HTML tag name, or
if any of the argument names are not valid HTML attribute names.

\h4(
  id="dir-cowel_html_self_closing_element"
){\cowdoc_dir{cowel_html_self_closing_element} \c{mdash} Self-closing HTML element}

\pre{
\cowel_highlight_as("markup-tag"){cowel_html_self_closing_element}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){string},
  \cowel_highlight_as("markup-attr"){attr}: \cowel_highlight_as("keyword-type"){lazy(group pack named string)?},
): \cowel_highlight_as("keyword-type"){block}
}

The \cowdoc_dir{cowel_html_self_closing_element} directive generates a self-closing HTML element.
That is, an element with no content,
and where there is no closing tag.
Content is ignored.

The name of the HTML element is contained in the \cowdoc_attr{name} parameter,
and the attributes within the HTML element
are contained within the \cowdoc_attr{attr} parameter.

\Bex{
COWEL markup:
\cowblock{\literally{
Horizontal rule:
\cowel_html_self_closing_element(hr, (id = abc)){ignored}
}}
Generated HTML:
\htmlblock{
Horizontal rule:
<hr id=abc />
}
}

\h3(id="new-content-policies"){Content policies}

As explained in \ref("#contexts-and-output"),
all content within the document and produced by directives is fed into a content policy,
which, in turn, feeds content into some parent content policy.

The table below lists directives which process content using some content policy.

\Bindent{
\table{
  \tr{
    \th{Directive}
    \th{Content policy}
    \th{Notes}
  }
  \tr{
    \td{\cowdoc_dir{cowel_to_html}}
    \td{HTML policy}
    \td{}
  }
  \tr{
    \td{\cowdoc_dir{cowel_highlight}}
    \td{highlight policy}
    \td{see \ref("#dir-cowel_highlight")}
  }
  \tr{
    \td{\cowdoc_dir{cowel_paragraphs}}
    \td{paragraphs policy}
    \td{see \ref("#dir-cowel_paragraphs")}
  }
  \tr{
    \td{\cowdoc_dir{cowel_no_invoke}}
    \td{no-invoke policy}
    \td{}
  }
  \tr{
    \td{\cowdoc_dir{cowel_actions}}
    \td{no-invoke policy}
    \td{}
  }
  \tr{
    \td{\cowdoc_dir{cowel_text_only}}
    \td{text-only policy}
  }
  \tr{
    \td{\cowdoc_dir{cowel_text_as_html}}
    \td{text-as-html policy}
  }
  \tr{
    \td{\cowdoc_dir{cowel_source_as_text}}
    \td{source-as-text policy}
  }
}
}

\h4(
  id = "dir-cowel_to_html"
){\cowdoc_dir{cowel_to_html} \c{mdash} Process with to-HTML policy}

\pre{
\cowel_highlight_as("markup-tag"){cowel_to_html}(){...}: \cowel_highlight_as("keyword-type"){block}
}

\cowdoc_dir{cowel_to_html} simply processes the provided content using the to-HTML policy.

The purpose of this policy/directive is mainly to
feed its parent policy pure HTML content,
rather than a mixture of plaintext and HTML.
This also suppresses paragraph splitting, syntax highlighting,
and other such "special treatments" of plaintext,
since none of those operate on HTML.

\Bex{
Since HTML is not syntax-highlighted,
we can insert special characters like U+00AD SOFT HYPHEN
into code snippets, without interfering with syntax highlighting:
\cowblock{\literally{
Use of
\cowel_html_element(code){
\cowel_highlight(cpp){reinterpret_\
\cowel_to_html{\cowel_char_by_name{SOFT HYPHEN}}\
cast}
}
is discouraged.
}}

This renders as:
\Bindent{
Use of
\code(cpp){reinterpret_cast} is discouraged.
}
Or, if line wrapping takes place in the middle of the highlighted keyword,
it renders as:
\Bindent{
Use of
\tt{\cowel_highlight_as(keyword){reinterpret_}-\br{}
\cowel_highlight_as(keyword){cast}} is discouraged.
}
}

\h4(
  id = "dir-cowel_no_invoke"
){\cowdoc_dir{cowel_no_invoke} \c{mdash} Process with no-invoke policy}

\pre{
\cowel_highlight_as("markup-tag"){cowel_no_invoke}(){...}: \cowel_highlight_as("keyword-type"){block}
}

\cowdoc_dir{cowel_no_invoke} processes the provided content
using the no-invoke policy.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_no_invoke{Undefined directive: \awoo}
}}
Generated HTML:
\htmlblock{
Undefined directive: \\awoo
}
Under the no-invoke policy selected by \cowdoc_c{no_invoke},
\cowdoc_c{\\awoo} is not invoked,
but its source code is fed into the current policy as plaintext.
This is particularly useful when writing code blocks
which contain character escapes (e.g. containing \code(cpp){"\\n"} in C++)
because such escapes should not treated as COWEL directives.
}

\Bnote{
COWEL comments and COWEL escape sequences are processed as usual.
That is, comments are ignored, and escapes are expanded.
}

\h4(
  id = "dir-cowel_actions"
){\cowdoc_dir{cowel_actions} \c{mdash} Process with actions policy}

\pre{
\cowel_highlight_as("markup-tag"){cowel_actions}(){...}: \cowel_highlight_as("keyword-type"){block}
}

\cowdoc_dir{cowel_actions} processes the provided content
using the actions policy.

This is particularly useful in macros and surrounding macros
because it prevents whitespace from being emitted into the HTML file.
Normally, whitespace is preserved,
unless explicitly eliminated (e.g. with newline escapes or commas).

\Bex{
COWEL markup:
\cowblock{\literally{
no escapes:
\cowel_macro(a)
\cowel_macro(b)
\cowel_macro(c)
end.
newline escapes:
\cowel_macro(h)\
\cowel_macro(j)\
\cowel_macro(k)\
end.
actions:
\cowel_actions{
\: Documentation for x:
\cowel_macro(x)

\: In here, we can add as much whitespace as we want.
\: It won't add anything to the generated HTML ðŸ˜ƒ
\cowel_macro(y)

Text is also ignored, just like whitespace,
but it is recommended to use comments even in actions
because it expresses intent more clearly.
\cowel_macro(z)
}\
end.
}}
Generated HTML:
\htmlblock{
no escapes:



end.
newline escapes:
end.
actions:
end.
}
Note that nine macros have also been defined by the COWEL markup,
but macro definitions produce no output.
}

\h4(
  id = "dir-cowel_text_only"
){\cowdoc_dir{cowel_text_only} \c{mdash} Process with text-only policy}

\pre{
\cowel_highlight_as("markup-tag"){cowel_text_only}(){...}: \cowel_highlight_as("keyword-type"){block}
}

\cowdoc_dir{cowel_text_only} processes the provided content
using the text-only policy.

\Bex{
COWEL markup:
\cowblock{\literally{
Hello, \cowel_html_element(strong){strong} world!
\cowel_text_only{Hello, \cowel_html_element(strong){strong} world!}
}}
Generated HTML:
\htmlblock{
Hello, <strong>strong</strong> world!
Hello, strong world!
}
As can be seen, only plaintext "makes it through",
whereas HTML is stripped.
}

\Bnote{
This policy is used internally when processing arguments in various places,
such as in the \cowdoc_c{strong} positional argument to
\cowdoc_dir{cowel_html_element} in the example above.

It is mainly useful in situations where it makes no sense to have non-plaintext content.
}

\h4(
  id = "dir-cowel_text_as_html"
){\cowdoc_dir{cowel_text_as_html} \c{mdash} Process with text-as-HTML policy}

\pre{
\cowel_highlight_as("markup-tag"){cowel_text_as_html}(){...}: \cowel_highlight_as("keyword-type"){block}
}

\cowdoc_dir{cowel_no_invoke} processes the provided content
using the text-as-HTML policy.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_text_as_html{Hello, <strong>strong</strong> world!}
}}
Generated HTML:
\htmlblock{
Hello, <strong>strong</strong> world!
}
As can be seen, the provided text is reinterpreted as HTML.
}

\Bwarn{
This directive should be used with great caution
because it can easily result in producing malformed HTML.
While there are legitimate uses (e.g. inline SVG images and other large HTML blocks),
\cowdoc_dir{cowel_html_element} and other safer directives should be preferred.
}

\h4(
  id = "dir-cowel_source_as_text"
){\cowdoc_dir{cowel_source_as_text} \c{mdash} Process with source-as-text policy}

\pre{
\cowel_highlight_as("markup-tag"){cowel_source_as_text}(){...}: \cowel_highlight_as("keyword-type"){block}
}

\cowdoc_dir{cowel_no_invoke} processes the provided content
using the source-as-text policy.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_source_as_text{
\: Comment ...
Hello \source_as_text \{ ... \}
}
}}
Generated HTML:
\htmlblock{\literally{
\: Comment ...
Hello \source_as_text \{ ... \}
}}
}

\Bnote{
This directive is mainly useful for writing COWEL code blocks,
where all content within is treated literally, including comments.

It can be seen as a more extreme form of \cowdoc_dir{cowel_no_invoke},
and is more niche in its applications.
}

\h3(id="new-syntax-highlighting"){Syntax highlighting}

Syntax highlighting improves the readability of inline code and code snippets
by applying different formatting (usually colors)
based on the syntactical meaning of text.
Many examples can be found in this document.

\h4(
  id = "dir-cowel_highlight"
){\cowdoc_dir{cowel_highlight} \c{mdash} Perform syntax highlighting}

\pre{
\cowel_highlight_as("markup-tag"){cowel_highlight}(
  \cowel_highlight_as("markup-attr"){lang}: \cowel_highlight_as("keyword-type"){string},
){...}: \cowel_highlight_as("keyword-type"){block}
}

The \cowdoc_dir{cowel_highlight}
processes content using the highlight policy,
which wraps parts of code in HTML tags for the purpose of syntax highlighting.

\cowdoc_dir{cowel_highlight} has a single \cowdoc_attr{lang} parameter.
This specifies the name of language (e.g. \tt{cowel})
in which the content is to be highlighted.
The name has to be one of the language short names
supported by the \ref("https://github.com/Eisenwave/ulight"){Âµlight syntax highlighter},
which is the highlighter that COWEL uses internally.

\h4(
  id = "dir-cowel_highlight_as"
){\cowdoc_dir{cowel_highlight_as} \c{mdash} Syntax highlight override}

\pre{
\cowel_highlight_as("markup-tag"){cowel_highlight_as}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){string},
){...}: \cowel_highlight_as("keyword-type"){block}
}

The \cowdoc_dir{cowel_highlight_as} directive forces certain syntax highlighting
to be applied to some text;
it is a manual override for when automatic syntax highlighting is insufficient or broken.
This is done by wrapping the given content in HTML tags for syntax highlighting
and feeding the provided content, converted to HTML into the surrounding policy,
so it is not subject to automatic highlighting.

\cowdoc_dir{cowel_highlight_as} has a single \cowdoc_attr{name} parameter,
which is the Âµlight \dfn{long name} for a highlight type.

\Btip{
You can obtain a list of possible long names at
\ref("https://github.com/Eisenwave/ulight/blob/main/include/ulight/ulight.h"){\tt{ulight.h}}
from the definition of \code(cpp){enum ulight_highlight_type}.
The long name is the enumerator name without the \tt{ULIGHT_HL} prefix,
all lowercase, and with hyphens instead of underscores.
}

\Bex{
It is possible to mix automatic syntax highlighting with manual overrides:
\cowblock{\literally{
\: _Int128 is manually highlighted as a type keyword,
\: and x is automatically highlighted as an identifier.
\cowel_html_element(code){\
\cowel_highlight(c){\cowel_highlight_as("keyword-type"){_Int128} x}\
}
}}
This generates the HTML (subject to change):
\htmlblock{
<code><h- data-h=kw_type>_Int128</h-> <h- data-h=id>x</h-></code>
}
It renders as \code(c){\cowel_highlight_as("keyword-type"){_Int128} x}.
}

\Bnote{
While it is also possible to produce the highlighting tags using
\cowdoc_c{\\cowel_html_element("h-","data-h"=kw_type){_Int128}},
the "short names" (e.g. \cowdoc_c{kw_type}) are not stable,
i.e. they are more likely to change.
Only Âµlight long names should be used directly.
}

\h4(
  id = "dir-cowel_highlight_phantom"
){\cowdoc_dir{cowel_highlight_phantom} \c{mdash} Syntax highlight phantom text}

\pre{
\cowel_highlight_as("markup-tag"){cowel_highlight_phantom}(){...}: \cowel_highlight_as("keyword-type"){block}
}

The \cowdoc_dir{cowel_highlight_phantom} directive
can be used to further customize syntax highlighting.
It outputs \dfn{phantom text}, which is fed into the syntax highlighter,
but is not part of the output content.

The provided content is processed using a text-only policy (\ref("#contexts-and-output")).
If the current policy is a highlight policy,
the text output by the former is turned into phantom text within the latter.
Otherwise, the generated text is discarded.
All arguments are ignored.

\Bex{
Using \cowdoc_dir{cowel_highlight_phantom},
we can control whether a JSON string is interpreted as a markup key,
or as a string value:
\cowblock{
In JSON, there are
\\cowel_html_element(code){\\cowel_highlight(json){\\cowel_highlight_phantom{\\\N{LEFT CURLY BRACKET}}"keys"}}
and
\\cowel_html_element(code){\\cowel_highlight(json){"values"}}.
}
Using the highlight theme of this document, this renders as:
\Bindent{
In JSON, there are
\code(json){\cowel_highlight_phantom{\N{LEFT CURLY BRACKET}}"keys"}
and \code(json){"values"}.
}
Notice that the color of \code(json){\cowel_highlight_phantom{\N{LEFT CURLY BRACKET}}"keys"} is different
because it is highlighted as if it was positioned like:
\codeblock(json){
\N{LEFT CURLY BRACKET}"keys"
}
}

\h3(id="new-paragraph-control"){Paragraph control}

Dividing content into paragraphs manually would take a huge amount of effort,
so COWEL provides means of doing so semi-automatically.
Text within in a paragraphs policy (\ref("#contexts-and-output"))
is automatically wrapped in paragraphs (\cowdoc_html{<p>...</p>}),
divided at blank lines.

While content expanded from macros and from \cowdoc_dir{cowel_include}
is fed into the surrounding content policy
(which may be a paragraphs policy) directly,
directives are generally treated as "black boxes"
for the purpose of paragraph splitting,
and they neither begin nor end a paragraph.
The following paragraph control directives define interactions
between paragraph splitting and directives.

\h4{Paragraph splitting}

At the top-level in the document and within the content of certain directives,
\dfn{paragraph splitting} takes place.
All content in COWEL is either \dfn{inline content}, \dfn{block content}, or \dfn{meta content}.
Text and escape sequences are inline content,
and directives are sometimes inline and sometimes block content.
Certain directives (e.g. \cowdoc_dir{comment}) that don't generate anything rendered are meta content.

The process of paragraph splitting works as follows:
\ul{
  \li{
    Blank-line-separated blocks of inline content is wrapped in in \cowdoc_html{<p>...</p>} tags.
    Meta content is not counted as a blank line, so it "continues" inline content,
    but no effort is made to wrap it in \cowdoc_html{<p>...</p>}.
  }
  \li{
    Block content stays untouched, i.e. it is not wrapped in \cowdoc_html{<p>...</p>}.
    However, it also terminates prior inline content, like a blank line.
  }
}

\Bex{
COWEL markup:
\cowblock{
First paragraph.

Second paragraph.
\\blockquote{This is a block directive.}
}
Generated HTML:
\htmlblock{
<p>First paragraph.</p>

<p>Second paragraph.</p>
<blockquote>This is a block directive.</blockquote>
}
}

\h4(
  id = "dir-cowel_paragraphs"
){\cowdoc_dir{cowel_paragraphs} \c{mdash} Perform paragraph splitting}

\pre{
\cowel_highlight_as("markup-tag"){cowel_paragraphs}(){...}: \cowel_highlight_as("keyword-type"){block}
}

The \cowdoc_dir{cowel_paragraphs} directive
creates a paragraphs policy (\ref("#contexts-and-output"))
and feeds all provided content into that policy.
The beginning and end of the provided content are considered to be outside a paragraph.
All arguments are ignored.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_paragraphs{
First paragraph.

Second paragraph.
}
}}

Generated HTML:
\htmlblock{
<p>First paragraph.</p>

<p>Second paragraph.</p>
}
}

\Bnote{
At a top-level within the document,
paragraph splitting takes place implicitly,
as if the whole document was wrapped in \cowdoc_dir{cowel_paragraphs}.

However, this does not extend recursively,
so if one wants to have paragraph splitting inside say,
\cowdoc_dir{cowel_html_\c{shy}element},
\cowdoc_dir{cowel_paragraphs} has to be used.
}

\h4(
  id = "dir-cowel_paragraph_enter"
){\cowdoc_dir{cowel_paragraph_enter} \c{mdash} Enter a paragraph}

\pre{
\cowel_highlight_as("markup-tag"){cowel_paragraph_enter}(): \cowel_highlight_as("keyword-type"){block}
}

If the current content policy is a paragraphs policy and
and the paragraph state is "outside",
the paragraph state becomes "inside",
and a \cowdoc_html{<p>} tag is emitted.
Otherwise, has no effect.

\Bex{
COWEL markup, assuming a surrounding paragraphs policy:
\cowblock{\literally{
\cowel_char_by_name{DIGIT ONE}. First paragraph

\cowel_paragraph_enter\cowel_char_by_name{DIGIT TWO}. Second paragraph
}}

Generated HTML:
\htmlblock{
1<p>. First paragraph</p>

<p>2. Second paragraph</p>
}

As explained, directives are "black boxes" for paragraph splitting,
so when the paragraphs policy processes \cowdoc_dir{cowel_char_by_name},
it does not automatically begin a paragraph.
}

\Btip{
\cowdoc_dir{cowel_paragraph_enter} should rarely be used directly,
but from within macros.

For example, the user can define an \cowdoc_dir{N} directive which combines
\cowdoc_dir{cowel_para\c{shy}graph_enter} and \cowdoc_dir{cowel_\c{shy}char_by_name}.
}

\h4(
  id = "dir-cowel_paragraph_leave"
){\cowdoc_dir{cowel_paragraph_leave} \c{mdash} Leave a paragraph}

\pre{
\cowel_highlight_as("markup-tag"){cowel_paragraph_leave}(): \cowel_highlight_as("keyword-type"){block}
}

If the current content policy is a paragraphs policy and
and the paragraph state is "inside",
the paragraph state becomes "outside",
and a closing \cowdoc_html{</p>} tag is emitted.
Otherwise, has no effect.

\Bex{
COWEL markup, assuming a surrounding paragraphs policy:
\cowblock{\literally{
Paragraph 1:
\cowel_html_self_closing_element(hr)

Paragraph 2:
\cowel_paragraph_leave\cowel_html_self_closing_element(hr)
}}

Generated HTML:
\htmlblock{
<p>Paragraph 1:
<hr/></p>

<p>Paragraph 2:
</p><hr/>
}

As explained, directives are "black boxes" for paragraph splitting,
so when the paragraphs policy processes \cowdoc_dir{cowel_html_self_closing_element},
it does not automatically leave a paragraph.
This would be necessary because horizontal rules (\cowdoc_html{<hr/>})
are not supposed to be inside a paragraph.
}

\Btip{
\cowdoc_dir{cowel_paragraph_leave} should rarely be used directly,
but from within macros.

For example, the user can define a \cowdoc_dir{hr} directive which combines
\cowdoc_dir{cowel_para\c{shy}graph_leave} and
\cowdoc_dir{cowel_\c{shy}html_self_closing_element}.
}

\h4(
  id = "dir-cowel_paragraph_inherit"
){\cowdoc_dir{cowel_paragraph_inherit} \c{mdash} Activate paragraph splitting inside a directive}

\pre{
\cowel_highlight_as("markup-tag"){cowel_paragraph_inherit}(): \cowel_highlight_as("keyword-type"){block}
}

\Bimp{
There is no support for programmatic directives yet,
so this directive is currently useless.
There are plans to add a WASM scripting API from which
\cowdoc_dir{cowel_paragraph_inherit} may be used to alter behavior.
}

As already stated,
paragraph splitting generally treats directives as "black boxes".
However, content expanded from \cowdoc_dir{cowel_include} and macros
\dfn{inherits} the surrounding paragraph for splitting,
i.e. any content produced by such directives is fed directly into the paragraphs policy.
\cowdoc_dir{cowel_paragraph_inherit} can be used inside programmatic directives
defined by the user to achieve the same behavior.

\h3(id="new-file-management"){File management}

Once projects get larger,
it often becomes difficult to manage everything in a single file.
Also, tooling may benefit from having separate files.
For example, keeping separate SVG files
or CSS files may have better IDE support than writing these out directly inside of COWEL.

COWEL provides directives to load content from other files.

\h4(
  id = "dir-cowel_include"
){\cowdoc_dir{cowel_include} \c{mdash} Include a sub-document}

\pre{
\cowel_highlight_as("markup-tag"){cowel_include}(\cowel_highlight_as("markup-attr"){path}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){block}
}

The \cowdoc_dir{cowel_include} directive loads the content from another COWEL document,
and processes it using the current content policy.
The given \cowdoc_attr{path} is the path to the included document,
relative to the current file.

If the current content policy is a paragraphs policy (\ref("#contexts-and-output")),
paragraph splitting of the included sub-document takes place
as if its contents were expanded directly where \cowdoc_dir{cowel_include} appears.
In other words, \cowdoc_dir{cowel_include} inherits the paragraph context,
or is \em{not} a "black box" to paragraph splitting.

\Bex{
Say we have another \tt{test.cow} files containing:
\cowblock{\literally{
Hello, includes!

Next paragraph.
}}
When using \cowdoc_dir{cowel_include},
the contents of the other file are substituted where we have written \cowdoc_dir{cowel_include},
which means that imported content also plays nicely with paragraph splitting:
\cowblock{\literally{
First paragraph.
\cowel_include{test.cow}
}}
Generated HTML:
\htmlblock{
<p>First paragraph.
Hello, includes!</p>

<p>Next paragraph.</p>
}
}

\Btip{
It is common practice to collect macros and other reusable components in separate documents,
and to \cowdoc_dir{cowel_include} them when needed.
This can help you avoid copying boilerplate between multiple documents.

It is also common to split documents into multiple files that are combined using a sequence
of \cowdoc_dir{cowel_include}s.
}

\h4(
  id = "dir-cowel_include_text"
){\cowdoc_dir{cowel_include_text} \c{mdash} Include text from a file}

\pre{
\cowel_highlight_as("markup-tag"){cowel_include_text}(\cowel_highlight_as("markup-attr"){path}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){str}
}

The \cowdoc_dir{cowel_include_text} directive returns a \cowdoc_type{str}
containing the UTF-8 text contents of another file.
The given \cowdoc_attr{path} is the path to the included document,
relative to the current file.
An error is raised if the contents of the designated file
could not be read.

\Bex{
Say we have a JavaScript file \tt{example.js} which we want to keep separate from the document.
We can then include it into a \cowdoc_dir{script} block to use it as a script,
or we can include it into a \cowdoc_dir{codeblock} to display its contents.
\cowblock{\literally{
\codeblock(js){
// code included from example.js:
\cowel_include_text{example.js}
}
}}
Assuming that \tt{example.js} is located in the same directory as the document
and that loading the file succeeds,
this renders as: 
\codeblock(js){
// code included from example.js:
\cowel_include_text("example.js")
}
}

\h3(id="new-aliases"){Aliases and macros}

\h4(
  id = "dir-cowel_alias"
){\cowdoc_dir{cowel_alias} \c{mdash} Define aliases for an existing directive}

\pre{
\cowel_highlight_as("markup-tag"){cowel_alias}(
  \cowel_highlight_as("markup-attr"){names}: \cowel_highlight_as("keyword-type"){pack string},
){...}: \cowel_highlight_as("keyword-type"){unit}
}

The \cowdoc_dir{cowel_alias} directive defines one or more aliases for an existing directive.
The content of \cowdoc_dir{cowel_alias} is converted to text,
and must be the name of an existing directive or directive alias.
Each positional argument is converted to text,
and results in the definition of a new directive alias.
After processing \cowdoc_dir{cowel_alias},
the target can also be invoked using the alias name.

A fatal error is raised if
\ul{
  \li{generation of the alias or target names is erroneous,}
  \li{the target name or any of the alias names are empty,}
  \li{the target name or any of the alias names are not valid directive names,}
  \li{the target was not found, or}
  \li{an alias name matches the name of an existing macro or alias.}
}

\Bex{
One or multiple aliases can be defined as follows:
\cowblock{\literally{
\cowel_alias(N){cowel_char_by_name}
\N("DIGIT ZERO")               \: OK, equivalent to \cowel_char_by_name("DIGIT ZERO")

\cowel_alias(incl, include){cowel_include}
\incl("file.cow")              \: OK, equivalent to \cowel_include("file.cow")
\include("file.cow")           \: OK, same

\cowel_alias{cowel_to_html}    \: OK, but no effect

\cowel_alias{\N("???")}        \: error: generation of target name failed
\cowel_alias{??}               \: error: invalid target name
\cowel_alias{undefined}        \: error: target not found
\cowel_alias("?"){cowel_alias} \: error: invalid alias name
\cowel_alias(N){N}             \: error: redefinition of N
}}
}

\h4(
  id = "dir-cowel_macro"
){\cowdoc_dir{cowel_macro} \c{mdash} Define a macro}

\pre{
\cowel_highlight_as("markup-tag"){cowel_macro}(
  \cowel_highlight_as("markup-attr"){names}: \cowel_highlight_as("keyword-type"){pack string},
){...}: \cowel_highlight_as("keyword-type"){unit}
}

The \cowdoc_dir{cowel_macro} directive defines a block of content which
can be processed at a later point in the document.
The provided content is not processed, but remembered.
Each positional argument is converted to text,
and results in the definition of a new macro.
After processing \cowdoc_dir{cowel_macro},
the target can also be invoked using the macro name.
Named arguments are ignored.

A fatal error occurs if
\ul{
  \li{generation of the alias or target names is erroneous,}
  \li{any macro name is not a valid directive name (this includes empty names), or}
  \li{a macro name matches the name of an existing macro or alias.}
}

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_macro(m,x){Hello, macros!}\
\m
\x
}}
Generated HTML:
\htmlblock{
Hello, macros!
Hello, macros!
}
}

When a macro is processed,
the behavior is as if \cowdoc_dir{cowel_paragraph_inherit} (\ref("#dir-cowel_paragraph_inherit"))
was invoked immediately before processing the content in the macro definition.
This means that blank lines in the macro definition
may also result in paragraph splits outside the macro.

\h4(
  id = "dir-cowel_put"
){\cowdoc_dir{cowel_put} \c{mdash} Process provided macro content or arguments}

\pre{
\cowel_highlight_as("markup-tag"){cowel_put}(
  \cowel_highlight_as("markup-attr"){else}: \cowel_highlight_as("keyword-type"){lazy any},
){...}: \cowel_highlight_as("keyword-type"){any}
}

The \cowdoc_dir{cowel_put} directive processes content
which was provided when a macro was invoked.

The content provided to \cowdoc_dir{cowel_put} is converted to text,
and \dfn{designates}
\ul{
  \li{
    if that text is empty, the provided macro content;
  }
  \li{
    otherwise, if that text expands to only ASCII digits,
    the provided positional macro argument at the index obtained by parsing the digits
    (counting starts at zero);
  }
  \li{
    otherwise, if there exists a named macro argument whose name matches the target text,
    that argument;
  }
  \li{
    otherwise, nothing.
  }
}

\cowdoc_dir{cowel_put} has the following effect:
\ul{
  \li{
    If any content is designated,
    the designated content is processed.
  }
  \li{
    Otherwise, if an argument matches the \cowdoc_attr{else} parameter,
    the content within the \cowdoc_attr{else} parameter is processed.
  }
  \li{
    Otherwise, an error is raised.
  }
}

\Bex{
COWEL markup:
\cowblock{\literally{
\: \cowel_put designates content
\cowel_macro(content){\cowel_put}\
\content{Content}

\: \cowel_put designates first positional argument
\cowel_macro(pos){\cowel_put{0}}\
\pos(Positional)

\: \cowel_put designates named argument with name "n"
\cowel_macro(named){\cowel_put{n}}\
\named(n = Named)

\: \cowel_put designates the first positional argument and has a fallback
\: Note that equivalently, we could use \cowel_put(Failure){0}.
\cowel_macro(try){\cowel_put(else=Failure){0}}\
\try(Success)
\try

\: All together:
\cowel_macro(m){\cowel_put{greeting}, \cowel_put\cowel_put{0}}\
\m(greeting = "Hello, !"){macros}
}}
Generated HTML:
\htmlblock{
Content

Positional

Named

Success
Failure

Hello, macros!
}
}

The behavior is erroneous if \cowdoc_dir{cowel_put} is not expanded from a macro,
such as when \cowdoc_dir{cowel_put} appears at a top-level in the document.

\Bnote{
\cowdoc_dir{cowel_macro} is not processed in any special way,
meaning that it cannot be used for "macro substitution" directly:
\cowblock{\literally{
\cowel_macro(m){\cowel_source_as_text{\cowel_put}}\
\m
}}
Generated HTML:
\htmlblock{
\\cowel_put
}
However, \cowdoc_dir{cowel_put} accesses the inputs to the macro invocation
which expands \cowdoc_dir{cowel_put}:
\cowblock{\literally{
\cowel_macro(m){\cowel_put}\
\m{\cowel_put}
}}
This results in a fatal error because when \cowdoc_dir{m} is processed,
the \cowdoc_dir{cowel_put} in the macro definition
expands to the top-level \cowdoc_dir{cowel_put}.
That \cowdoc_dir{cowel_put} in \cowdoc_c{\\m{\\cowel_put}}
is not expanded from any macro.
This functionality is implemented by tracking the "stack frame"
where content was expanded from (or none, in the case of the document top level).
This also makes it possible to deeply nest \cowdoc_dir{cowel_put}
within other directives while still referring to parameters of the macro invocation:
\cowblock{\literally{
\cowel_macro(m){\cowel_to_html{\cowel_put}}\
\: OK, equivalent to \cowel_to_html{...}
\: Notably, the expanded \cowel_put refers to the content provided to \m,
\: not to the content provided to \cowel_to_html (which would be \cowel_put).
\m{...}
}}
}

\Bwarn{
Expanding \cowdoc_dir{cowel_put} with the same input multiple times
results in multiple processing of the same provided content.
Sometimes this is useful,
but it can have unintended side effects:
\cowblock{\literally{
\cowel_macro(twice){\cowel_put\cowel_put}\
\: error: multiple definitions of alias "\N" for "\cowel_char_by_name"
\twice{\cowel_alias(N){cowel_char_by_name}}
}}
}

\h3(id="new-invocations"){Invocations}

\h4(
  id = "dir-cowel_invoke"
){\cowdoc_dir{cowel_invoke} \c{mdash} Invoke a directive}

\pre{
\cowel_highlight_as("markup-tag"){cowel_invoke}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){string},
){...}: \cowel_highlight_as("keyword-type"){any}
}

The \cowdoc_dir{cowel_invoke} directive invokes a directive by name.
This process is called a \dfn{dynamic invocation}.
Most invocations are \dfn{static invocations}.

The name of the invoked directive is provided as the first positional argument.
All other arguments are ignored.
The content provided to \cowdoc_dir{cowel_invoke}
is the content provided to the invoked directive.

\Bex{
Any directive \cowdoc_dir{abc} can be invoked statically or dynamically:
\cowblock{\cowel_invoke(literally){
\: Static invocation of directive named "abc".
\abc{...}
\: Static invocation of directive named "cowel_invoke",
\: which performs an equivalent dynamic invocation of "abc".
\cowel_invoke(abc){...}
}}
}

\Btodo{
It is also planned to allow providing arguments to the invoked directive,
but it may be better to add "argument groups" to the syntax first,
so that they can be bundled up in an \cowdoc_attr{args} group.
To avoid changing how \cowdoc_dir{cowel_invoke} works in the future,
argument forwarding is not supported at all right now.
}

\h3(id="type-conversions"){Type conversions}

\h4(
  id = "dir-cowel_to_str"
){\cowdoc_dir{cowel_to_str} \c{mdash} Convert to \cowdoc_type{str}}

\pre{
\cowel_highlight_as("markup-tag"){cowel_to_str}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){unit}): \cowel_highlight_as("keyword-type"){str}
\cowel_highlight_as("markup-tag"){cowel_to_str}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){bool}): \cowel_highlight_as("keyword-type"){str}
\cowel_highlight_as("markup-tag"){cowel_to_str}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){base}: \cowel_highlight_as("keyword-type"){int} = 10, \cowel_highlight_as("markup-attr"){zpad}: \cowel_highlight_as("keyword-type"){int} = 0): \cowel_highlight_as("keyword-type"){str}
\cowel_highlight_as("markup-tag"){cowel_to_str}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}, \cowel_highlight_as("markup-attr"){format}: \cowel_highlight_as("keyword-type"){str} = "splice"): \cowel_highlight_as("keyword-type"){str}
\cowel_highlight_as("markup-tag"){cowel_to_str}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){str}
\cowel_highlight_as("markup-tag"){cowel_to_str}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){block}): \cowel_highlight_as("keyword-type"){str}
}

The \cowdoc_dir{cowel_to_str} directive produces similar output to splicing
(\ref("#splicing")),
but allows for additional parametrization.
The output resulting string depends on the input as follows:
\ul{
  \li{
    If \cowdoc_attr{x} is of type \cowdoc_type{int},
    the digits of \cowdoc_attr{x} are printed in the given \cowdoc_attr{base}.
    An error is raised if \cowdoc_attr{base} is outside the range
    \math{\mrow{\mo{[}\mn{2}\mo{,}\mn{36}\mo{]}}}.
    Digits with value greater than \math{\mn{9}} are represented using
    U+0061..U+007A LATIN SMALL LETTER A..Z.
    Zeros are prepended between the leading '\tt{-}' (if any)
    and the significant digits as follows:\ul{
      \li{If \cowdoc_attr{zpad} is negative, an error is raised.}
      \li{
        Otherwise, the \cowdoc_cp(0x30) character is prepended
        \math{\mrow{
          \mi{max}
          \mo(form=prefix, stretchy=false){(}
          \mi{z}\mo{âˆ’}\mi{d}
          \mo{,}
          \mn{0}
          \mo(form=prefix, stretchy=false){)}
        }}
        times, where
        \math{\mi{z}} is \cowdoc_attr{zpad} and
        \math{\mi{d}} is the amount of significant digits.
      }
    }
  }
  \li{
    If \cowdoc_attr{x} is of type \cowdoc_type{float},
    \ul{
      \li{
        if \cowdoc_attr{format} equals \cowdoc_c{"splice"},
        the result is the same as splicing \cowdoc_attr{x} into a \gterm{quoted-string};
      }
      \li{
        otherwise, if \cowdoc_attr{format} equals \cowdoc_c{"fixed"},
        the result is the same as that for \cowdoc_c{"splice"}
        except that the string representation has no exponent;
      }
      \li{
        otherwise, if \cowdoc_attr{format} equals \cowdoc_c{"scientific"},
        the result is the same as that for \cowdoc_c{"splice"}
        except that the string representation always has an exponent,
      }
      \li{
        otherwise, an error is raised.
      }
    }
  }
  \li{
    Otherwise, the result is the same as splicing \cowdoc_attr{x} into a \gterm{quoted-string}.
  }
}

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_to_str(unit)

\cowel_to_str(true)
\cowel_to_str(false)

\cowel_to_str(255)
\cowel_to_str(255, base=16)
\cowel_to_str(-255, zpad=5)

\cowel_to_str(1e10)
\cowel_to_str(1e10, format=splice)
\cowel_to_str(1e10, format=fixed)
\cowel_to_str(1e10, format=scientific)

\cowel_to_str("awoo")
\cowel_to_str({awoo})
}}

Generated HTML:
\htmlblock{
\cowel_to_str(unit)

\cowel_to_str(true)
\cowel_to_str(false)

\cowel_to_str(255)
\cowel_to_str(255, base=16)
\cowel_to_str(-255, zpad=5)

\cowel_to_str(1e10)
\cowel_to_str(1e10, format=splice)
\cowel_to_str(1e10, format=fixed)
\cowel_to_str(1e10, format=scientific)

\cowel_to_str("awoo")
\cowel_to_str({awoo})
}
}

\Bnote{
When \cowdoc_attr{x} is of type \cowdoc_type{float},
the round-tripping guarantee of splicing is retained regardless of \cowdoc_attr{format}.

Base prefixes such as '\tt{0x}' for hexadecimal integers are not printed,
but can easily be appended separately.
}

\h4(
  id = "dir-cowel_reinterpret_as_float"
){\cowdoc_dir{cowel_reinterpret_as_float} \c{mdash} Reinterpret as \cowdoc_type{float}}

\pre{
\cowel_highlight_as("markup-tag"){cowel_reinterpret_as_float}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){float}
}

Returns a value of type \cowdoc_type{float}
whose bit pattern is the same as that of \cowdoc_attr{x}.
That is, each bit in the base-2 representation of \cowdoc_attr{x}
is interpreted as a bit in the
binary64 representation of the \cowdoc_type{float}.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_reinterpret_as_float(0x3ff8000000000000)
}}
Generated HTML:
\htmlblock{
\: This should print 1.5
\cowel_reinterpret_as_float(0x3ff8000000000000)
}
}

Raises an error if \cowdoc_attr{x} is is not in the range
\math{\mrow{
  \mo{[}
  \mn{0}\mo{,}\msup{\mn{2}\mn{64}}
  \mo{)}
}}.

\Btip{
This directive is intended for low-level manipulation of floating-point numbers.
For example, it may be used to create a NaN value with a specific payload or sign.
}

\h4(
  id = "dir-cowel_reinterpret_as_int"
){\cowdoc_dir{cowel_reinterpret_as_int} \c{mdash} Reinterpret as \cowdoc_type{int}}

\pre{
\cowel_highlight_as("markup-tag"){cowel_reinterpret_as_int}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){int}
}

Returns a value of type \cowdoc_type{int}
whose bit pattern is the same as that of \cowdoc_attr{x}.
That is, each bit of the binary64 representation of \cowdoc_attr{x}
is interpreted as a bit in the
base-2 representation of the \cowdoc_type{int}.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_reinterpret_as_int(1.5)
\cowel_eq(cowel_reinterpret_as_int(1.5), 0x3ff8000000000000)
}}
Generated HTML:
\htmlblock{
\cowel_reinterpret_as_int(1.5)
\cowel_eq(cowel_reinterpret_as_int(1.5), 0x3ff8000000000000)
}
}

\Bnote{
The result is in the range \math{\mrow{
  \mo{[}
  \mn{0}\mo{,}\msup{\mn{2}\mn{64}}
  \mo{)}
}}.
}

\h3(id="basic-arithmetic-operations"){Basic arithmetic operations}

\cowel_macro(left_fold_math_func){\
\mathblock{\mrow{
\mi{\cowel_put}\
\mo(stretchy=false){(}\
\mo{â€¦}\
\mi{\cowel_put}\
\mo(stretchy=false){(}\
\mi{\cowel_put}\
\mo(stretchy=false){(}\
\msub{\mi{x}\mn{0}}\
\mo(separator=true){,}\
\msub{\mi{x}\mn{1}}\
\mo(stretchy=false){)}\
\mo(separator=true){,}\
\msub{\mi{x}\mn{2}}\
\mo(stretchy=false){)}\
\mo{â€¦}\
\mo(separator=true){,}\
\msub{\mi{x}\mi{n}}\
\mo(stretchy=false){)}\
}}\
}\
\
\cowel_macro(left_fold_math_op){\
\math{\mrow{
\msub{\mi{x}\mn{0}}\
\mo{\cowel_put}\
\msub{\mi{x}\mn{1}}\
\mo{\cowel_put}\
\mo{â€¦}\
\mo{\cowel_put}\
\msub{\mi{x}\mi{n}}\
}}\
}\

\h4(
  id = "dir-cowel_pos"
){\cowdoc_dir{cowel_pos} \c{mdash} Copy}

\pre{
\cowel_highlight_as("markup-tag"){cowel_pos}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_pos}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\mrow{\mo(form=prefix){+}\mi{x}}}.

If \cowdoc_attr{x} is of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{copy}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\Bnote{
The result is bitwise identical to \cowdoc_attr{x}.
}

\h4(
  id = "dir-cowel_neg"
){\cowdoc_dir{cowel_neg} \c{mdash} Negation}

\pre{
\cowel_highlight_as("markup-tag"){cowel_neg}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_neg}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\mrow{\mo(form=prefix){âˆ’}\mi{x}}}.

If \cowdoc_attr{x} is of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{negate}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\Bnote{
Negating positive zero results in negative zero, and vice versa.
}

\h4(
  id = "dir-cowel_abs"
){\cowdoc_dir{cowel_abs} \c{mdash} Absolute value}

\pre{
\cowel_highlight_as("markup-tag"){cowel_abs}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_abs}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns the absolute value of \cowdoc_attr{x}.

If \cowdoc_attr{x} is of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{abs}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_sqrt"
){\cowdoc_dir{cowel_sqrt} \c{mdash} Square root}

\pre{
\cowel_highlight_as("markup-tag"){cowel_sqrt}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\msqrt{\mi{x}}}.

The result is that of the IEEE-754 operation
\math{\mrow{\mi{squareRoot}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_trunc"
){\cowdoc_dir{cowel_trunc} \c{mdash} Round toward zero}

\pre{
\cowel_highlight_as("markup-tag"){cowel_trunc}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\mi{x}},
rounded to the next integer toward zero.

The result is that of the IEEE-754 operation
\math{\mrow{\mi{roundToIntegralTowardZero}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_floor"
){\cowdoc_dir{cowel_floor} \c{mdash} Round toward negative infinity}

\pre{
\cowel_highlight_as("markup-tag"){cowel_floor}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\mi{x}},
rounded to the next integer toward negative infinity.

The result is that of the IEEE-754 operation
\math{\mrow{\mi{roundToIntegralTowardNegative}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_ceil"
){\cowdoc_dir{cowel_ceil} \c{mdash} Round toward positive infinity}

\pre{
\cowel_highlight_as("markup-tag"){cowel_ceil}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\mi{x}},
rounded to the next integer toward positive infinity.

The result is that of the IEEE-754 operation
\math{\mrow{\mi{roundToIntegralTowardPositive}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_nearest"
){\cowdoc_dir{cowel_nearest} \c{mdash} Round toward the nearest integer}

\pre{
\cowel_highlight_as("markup-tag"){cowel_nearest}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\mi{x}},
rounded to the nearest integer,
with ties broken toward the integer with an even least significant digit.

The result is that of the IEEE-754 operation
\math{\mrow{\mi{roundToIntegralTiesToEven}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\Bnote{
This is also known as Banker's Rounding,
and is the default IEEE-754 rounding mode.
}

\h4(
  id = "dir-cowel_nearest_away_zero"
){\cowdoc_dir{cowel_nearest_away_zero} \c{mdash} Round toward the nearest integer, with ties broken away from zero}

\pre{
\cowel_highlight_as("markup-tag"){cowel_nearest_away_zero}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \math{\mi{x}},
rounded to the nearest integer,
with ties broken away from zero.

The result is that of the IEEE-754 operation
\math{\mrow{\mi{roundToIntegralTiesAwayZero}\mo(stretchy=false){(}\mi{x}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_min"
){\cowdoc_dir{cowel_min} \c{mdash} Minimum}

\pre{
\cowel_highlight_as("markup-tag"){cowel_min}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_min}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack float}): \cowel_highlight_as("keyword-type"){float}
}

Returns the lowest of the given values.

An error is raised of \cowdoc_attr{args} is empty.

If \cowdoc_attr{args} is a pack of type \cowdoc_type{float},
the result is that of the IEEE-754 operations
\left_fold_math_func{minimum}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

\Bnote{
\cowdoc_dir{cowel_min} is associative and commutative,
ignoring NaN representations.
}

\h4(
  id = "dir-cowel_max"
){\cowdoc_dir{cowel_max} \c{mdash} Maximum}

\pre{
\cowel_highlight_as("markup-tag"){cowel_max}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_max}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack float}): \cowel_highlight_as("keyword-type"){float}
}

Returns the greatest of the given values.

An error is raised of \cowdoc_attr{args} is empty.

If \cowdoc_attr{args} is a pack of type \cowdoc_type{float},
the result is that of the IEEE-754 operations
\left_fold_math_func{maximum}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

\Bnote{
\cowdoc_dir{cowel_max} is associative and commutative,
ignoring NaN representations.
}

\h4(
  id = "dir-cowel_add"
){\cowdoc_dir{cowel_add} \c{mdash} Addition}

\pre{
\cowel_highlight_as("markup-tag"){cowel_add}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_add}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \left_fold_math_op{+}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

An error is raised of \cowdoc_attr{args} is empty.

If \cowdoc_attr{args} is a pack of type \cowdoc_type{float},
the result is that of the IEEE-754 operations
\left_fold_math_func{addition}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

\h4(
  id = "dir-cowel_sub"
){\cowdoc_dir{cowel_sub} \c{mdash} Subtraction}

\pre{
\cowel_highlight_as("markup-tag"){cowel_sub}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_sub}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \left_fold_math_op{âˆ’}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

An error is raised of \cowdoc_attr{args} is empty.

If \cowdoc_attr{args} is a pack of type \cowdoc_type{float},
the result is that of the IEEE-754 operations
\left_fold_math_func{subtraction}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

\h4(
  id = "dir-cowel_mul"
){\cowdoc_dir{cowel_mul} \c{mdash} Multiplication}

\pre{
\cowel_highlight_as("markup-tag"){cowel_mul}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack int}): \cowel_highlight_as("keyword-type"){int}
\cowel_highlight_as("markup-tag"){cowel_mul}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \left_fold_math_op{Ã—}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

An error is raised of \cowdoc_attr{args} is empty.

If \cowdoc_attr{args} is a pack of type \cowdoc_type{float},
the result is that of the IEEE-754 operations
\left_fold_math_func{multiplication}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

\h4(
  id = "dir-cowel_div"
){\cowdoc_dir{cowel_div} \c{mdash} Division}

\pre{
\cowel_highlight_as("markup-tag"){cowel_div}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack float}): \cowel_highlight_as("keyword-type"){float}
}

Returns \left_fold_math_op{Ã·}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

An error is raised of \cowdoc_attr{args} is empty.

The result is that of the IEEE-754 operations
\left_fold_math_func{division}
for each \math{\msub{\mi{x}\mi{i}}} in \cowdoc_attr{args}.

\Bnote{
Division by zero does not raise an error.
Instead, it results in infinity or NaN depending on the dividend.
}

\h4(
  id = "dir-cowel_div_to_zero"
){\cowdoc_dir{cowel_div_to_zero} \c{mdash} Division rounded toward zero}

\pre{
\cowel_highlight_as("markup-tag"){cowel_div_to_zero}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
}

Returns the quotient of the division \math{\mrow{\mi{x}\mo{Ã·}\mi{y}}}
with rounding toward zero.

An error is raised of \cowdoc_attr{y} is zero.

\Bnote{
The result is that of the \tt{/} operator in C.
}

\h4(
  id = "dir-cowel_rem_to_zero"
){\cowdoc_dir{cowel_rem_to_zero} \c{mdash} Remainder rounded toward zero}

\pre{
\cowel_highlight_as("markup-tag"){cowel_rem_to_zero}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
}

Returns the remainder of the division \math{\mrow{\mi{x}\mo{Ã·}\mi{y}}}
with rounding toward zero.

An error is raised of \cowdoc_attr{y} is zero.

\Bnote{
The result is that of the \tt{\N{PERCENT SIGN}} operator in C.
The sign of the result is the sign of the dividend \cowdoc_attr{x}.
}

\h4(
  id = "dir-cowel_div_to_pos_inf"
){\cowdoc_dir{cowel_div_to_pos_inf} \c{mdash} Division rounded toward positive infinity}

\pre{
\cowel_highlight_as("markup-tag"){cowel_div_to_pos_inf}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
}

Returns the quotient of the division \math{\mrow{\mi{x}\mo{Ã·}\mi{y}}}
with rounding toward positive infinity.

An error is raised of \cowdoc_attr{y} is zero.

\h4(
  id = "dir-cowel_rem_to_pos_inf"
){\cowdoc_dir{cowel_rem_to_pos_inf} \c{mdash} Remainder rounded toward positive infinity}

\pre{
\cowel_highlight_as("markup-tag"){cowel_rem_to_pos_inf}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
}

Returns the remainder of the division \math{\mrow{\mi{x}\mo{Ã·}\mi{y}}}
with rounding toward positive infinity.

An error is raised of \cowdoc_attr{y} is zero.

\h4(
  id = "dir-cowel_div_to_neg_inf"
){\cowdoc_dir{cowel_div_to_neg_inf} \c{mdash} Division rounded toward negative infinity}

\pre{
\cowel_highlight_as("markup-tag"){cowel_div_to_neg_inf}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
}

Returns the quotient of the division \math{\mrow{\mi{x}\mo{Ã·}\mi{y}}}
with rounding toward negative infinity.

An error is raised of \cowdoc_attr{y} is zero.

\Bnote{
The result is that of the \tt{//} operator in Python.
}

\h4(
  id = "dir-cowel_rem_to_neg_inf"
){\cowdoc_dir{cowel_rem_to_neg_inf} \c{mdash} Remainder rounded toward negative infinity}

\pre{
\cowel_highlight_as("markup-tag"){cowel_rem_to_neg_inf}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){int}
}

Returns the remainder of the division \math{\mrow{\mi{x}\mo{Ã·}\mi{y}}}
with rounding toward negative infinity.

An error is raised of \cowdoc_attr{y} is zero.

\Bnote{
The result is that of the \tt{\N{PERCENT SIGN}} operator in Python.
The sign of the result is the sign of the divisor \cowdoc_attr{y}.
}

\h3(id="logical-operations"){Logical operations}

\Bnote{
There is no \cowdoc_dir{cowel_xor} logical operation
for "logical exclusive OR";
however, the same can be accomplished with \cowdoc_dir{cowel_ne}.
\cowdoc_dir{cowel_eq} can be used for logical equivalence.
}

\h4(
  id = "dir-cowel_not"
){\cowdoc_dir{cowel_not} \c{mdash} Logical NOT}

\pre{
\cowel_highlight_as("markup-tag"){cowel_not}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){bool}): \cowel_highlight_as("keyword-type"){bool}
}

Returns \cowdoc_c{true} if \cowdoc_attr{x} is \cowdoc_c{false},
otherwise \cowdoc_c{false}.

\h4(
  id = "dir-cowel_and"
){\cowdoc_dir{cowel_and} \c{mdash} Logical AND}

\pre{
\cowel_highlight_as("markup-tag"){cowel_and}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack lazy bool}): \cowel_highlight_as("keyword-type"){bool}
}

Returns \cowdoc_c{true} if none of \cowdoc_attr{args} is \cowdoc_c{false},
otherwise \cowdoc_c{false}.

\cowdoc_attr{args} is evaluated from left to right,
and any remaining elements are ignored once the result is known.

\Bex{
In the following example,
no error is raised despite the second argument containing a division by zero.
\cowblock{\literally{
\cowel_and(false, cowel_eq(0, cowel_div_to_zero(0, 0)))
}}
That is because the result of \cowdoc_dir{cowel_and} is already known
after the first \cowdoc_c{false}.
}

\h4(
  id = "dir-cowel_or"
){\cowdoc_dir{cowel_or} \c{mdash} Logical OR}

\pre{
\cowel_highlight_as("markup-tag"){cowel_or}(\cowel_highlight_as("markup-attr"){args}: \cowel_highlight_as("keyword-type"){pack lazy bool}): \cowel_highlight_as("keyword-type"){bool}
}

Returns \cowdoc_c{true} if any of \cowdoc_attr{args} is \cowdoc_c{true},
otherwise \cowdoc_c{false}.

\cowdoc_attr{args} is evaluated from left to right,
and any remaining elements are ignored once the result is known.

\h3(id="comparison-operations"){Comparison operations}

In all relational comparison below
(\cowdoc_dir{cowel_lt}, \cowdoc_dir{cowel_gt}, \cowdoc_dir{cowel_le}, and \cowdoc_dir{cowel_ge}),
if \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{str},
the comparison is performed lexicographically on the Unicode code points of the string.
The result is unspecified if either string is not valid UTF-8.
If two strings are equal up to the last common code point,
the shorter string is lexicographically less.

\Bnote{
Relational string comparison can be implemented by comparing the UTF-8 code units of a string.
}

Some of the operations below are specified in terms of
"compareQuietâ€¦" or "compareSignalingâ€¦" IEEE-754 operations.
This is only done to define behavior for infinities and NaNs;
there is no way to tell apart signaling and quiet operations in COWEL.

\h4(
  id = "dir-cowel_eq"
){\cowdoc_dir{cowel_eq} \c{mdash} Equals}

\pre{
\cowel_highlight_as("markup-tag"){cowel_eq}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){unit}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){unit}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_eq}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){null}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){null}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_eq}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){bool}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){bool}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_eq}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int},  \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_eq}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float},  \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_eq}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str},  \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){bool}
}

Return \cowdoc_c{true} if \math{\mrow{\mi{x}\mo{=}\mi{y}}},
otherwise \cowdoc_c{false}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{unit} or \cowdoc_type{null},
returns \cowdoc_c{true}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{compareQuietEqual}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_ne"
){\cowdoc_dir{cowel_ne} \c{mdash} Not equals}

\pre{
\cowel_highlight_as("markup-tag"){cowel_ne}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){unit}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){unit}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_ne}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){null}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){null}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_ne}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){bool}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){bool}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_ne}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int},  \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_ne}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float},  \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_ne}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str},  \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){bool}
}

Return \cowdoc_c{true} if \math{\mrow{\mi{x}\mo{â‰ }\mi{y}}},
otherwise \cowdoc_c{false}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{unit} or \cowdoc_type{null},
returns \cowdoc_c{false}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{compareQuietNotEqual}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}}.

\Bnote{
The result is \cowdoc_c{cowel_not(cowel_eq(x, y))}.
}

\h4(
  id = "dir-cowel_lt"
){\cowdoc_dir{cowel_lt} \c{mdash} Less than}

\pre{
\cowel_highlight_as("markup-tag"){cowel_lt}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_lt}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_lt}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){bool}
}

Return \cowdoc_c{true} if \math{\mrow{\mi{x}\mo{<}\mi{y}}},
otherwise \cowdoc_c{false}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{compareSignalingLess}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_gt"
){\cowdoc_dir{cowel_gt} \c{mdash} Greater than}

\pre{
\cowel_highlight_as("markup-tag"){cowel_gt}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_gt}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_gt}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){bool}
}

Return \cowdoc_c{true} if \math{\mrow{\mi{x}\mo{>}\mi{y}}},
otherwise \cowdoc_c{false}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{compareSignalingGreater}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_le"
){\cowdoc_dir{cowel_le} \c{mdash} Less than or equal}

\pre{
\cowel_highlight_as("markup-tag"){cowel_le}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_le}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_le}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){bool}
}

Return \cowdoc_c{true} if \math{\mrow{\mi{x}\mo{â‰¤}\mi{y}}},
otherwise \cowdoc_c{false}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{compareSignalingLessEqual}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}}.

\h4(
  id = "dir-cowel_ge"
){\cowdoc_dir{cowel_ge} \c{mdash} Greater than or equal}

\pre{
\cowel_highlight_as("markup-tag"){cowel_ge}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){int}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){int}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_ge}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){float}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){float}): \cowel_highlight_as("keyword-type"){bool}
\cowel_highlight_as("markup-tag"){cowel_ge}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}, \cowel_highlight_as("markup-attr"){y}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){bool}
}

Return \cowdoc_c{true} if \math{\mrow{\mi{x}\mo{â‰¥}\mi{y}}},
otherwise \cowdoc_c{false}.

If \cowdoc_attr{x} and \cowdoc_attr{y} are of type \cowdoc_type{float},
the result is that of the IEEE-754 operation
\math{\mrow{\mi{compareSignalingGreaterEqual}\mo(stretchy=false){(}\mi{x}\mo{,}\mi{y}\mo(stretchy=false){)}}}.

\h3(id="string-operations"){String operations}

\h4(
  id = "dir-cowel_str_length"
){\cowdoc_dir{cowel_str_length} \c{mdash} Length of string}

\pre{
\cowel_highlight_as("markup-tag"){cowel_str_length}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){int}
}

Returns the length of \cowdoc_attr{x}, in code points.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_str_length("")
\: U+0061 LATIN SMALL LETTER A
\cowel_str_length("a")
\: U+0061 LATIN SMALL LETTER A WITH DIAERESIS
\cowel_str_length("Ã¤")
\: U+1F1E9 Regional Indicator Symbol Letter D
\: U+1F1EA Regional Indicator Symbol Letter E
\cowel_str_length("ðŸ‡©ðŸ‡ª")
}}
Generated HTML:
\htmlblock{
\cowel_str_length("")
\cowel_str_length("a")
\cowel_str_length("Ã¤")
\cowel_str_length("ðŸ‡©ðŸ‡ª")
}
}

\h4(
  id = "dir-cowel_str_utf8_length"
){\cowdoc_dir{cowel_str_utf8_length} \c{mdash} Length of string in UTF-8 code units}

\pre{
\cowel_highlight_as("markup-tag"){cowel_str_utf8_length}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){int}
}

Returns the length of \cowdoc_attr{x}, in UTF-8 code units.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_str_utf8_length("")
\: U+0061 LATIN SMALL LETTER A
\cowel_str_utf8_length("a")
\: U+0061 LATIN SMALL LETTER A WITH DIAERESIS
\cowel_str_utf8_length("Ã¤")
\: U+1F1E9 Regional Indicator Symbol Letter D
\: U+1F1EA Regional Indicator Symbol Letter E
\cowel_str_utf8_length("ðŸ‡©ðŸ‡ª")
}}
Generated HTML:
\htmlblock{
\cowel_str_utf8_length("")
\cowel_str_utf8_length("a")
\cowel_str_utf8_length("Ã¤")
\cowel_str_utf8_length("ðŸ‡©ðŸ‡ª")
}
}

\Bnote{
COWEL strings should be internally stored as UTF-8,
so this operation should not require encoding the string as UTF-8.
Rather it accesses available information directly.
}

\h4(
  id = "dir-cowel_str_to_lower"
){\cowdoc_dir{cowel_str_to_lower} \c{mdash} Convert string to lowercase}

\pre{
\cowel_highlight_as("markup-tag"){cowel_str_to_lower}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){str}
}

Returns \cowdoc_attr{x} converted to lowercase.
That is, applies the
\ref("https://www.unicode.org/versions/Unicode17.0.0/core-spec/chapter-3/#G34078"){toLowercase Default Case Conversion}
as specified in Unicode,
without any language-sensitive mappings.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_str_to_lower("Awoo Ã„Ã–Ãœ 123")
}}
Generated HTML:
\htmlblock{
\cowel_str_to_lower("Awoo Ã„Ã–Ãœ 123")
}
}

\h4(
  id = "dir-cowel_str_to_upper"
){\cowdoc_dir{cowel_str_to_upper} \c{mdash} Convert string to uppercase}

\pre{
\cowel_highlight_as("markup-tag"){cowel_str_to_upper}(\cowel_highlight_as("markup-attr"){x}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){str}
}

Returns \cowdoc_attr{x} converted to uppercase.
That is, applies the
\ref("https://www.unicode.org/versions/Unicode17.0.0/core-spec/chapter-3/#G34078"){toUppercase Default Case Conversion}
as specified in Unicode,
without any language-sensitive mappings.

\Bex{
COWEL markup:
\cowblock{\literally{
\cowel_str_to_upper("Awoo Ã¤Ã¶Ã¼ StraÃŸe 123")
}}
Generated HTML:
\htmlblock{
\cowel_str_to_upper("Awoo Ã¤Ã¶Ã¼ StraÃŸe 123")
}
}

\h3{Variable management}

\h4(
  id = "dir-cowel_var_let"
){\cowdoc_dir{cowel_var_let} \c{mdash} Initialize a new variable}

\pre{
\cowel_highlight_as("markup-tag"){cowel_var_let}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str},
  \cowel_highlight_as("markup-attr"){value}: \cowel_highlight_as("keyword-type"){any} = null,
): \cowel_highlight_as("keyword-type"){unit}
}

Sets the value of a global variable named \cowdoc_attr{name} to \cowdoc_attr{value}.
An error is raised if such a variable already exists.

\h4(
  id = "dir-cowel_var_set"
){\cowdoc_dir{cowel_var_set} \c{mdash} Set an existing variable}

\pre{
\cowel_highlight_as("markup-tag"){cowel_var_set}(
  \cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str},
  \cowel_highlight_as("markup-attr"){value}: \cowel_highlight_as("keyword-type"){any},
): \cowel_highlight_as("keyword-type"){unit}
}

Sets the value of a global variable named \cowdoc_attr{name} to \cowdoc_attr{value}.
An error is raised if no such variable exists.

\h4(
  id = "dir-cowel_var_exists"
){\cowdoc_dir{cowel_var_exists} \c{mdash} Check whether a variable exists}

\pre{
\cowel_highlight_as("markup-tag"){cowel_var_exists}(\cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){bool}
}

Returns \cowdoc_c{true} if a variable named \cowdoc_attr{name} exists,
otherwise \cowdoc_c{false}.

\h4(
  id = "dir-cowel_var_get"
){\cowdoc_dir{cowel_var_get} \c{mdash} Get the value of a variable}

\pre{
\cowel_highlight_as("markup-tag"){cowel_var_get}(\cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){any}
}

Returns the value of the global variable named \cowdoc_attr{name}.
An error is raised if there is no such variable.

\h4(
  id = "dir-cowel_var_delete"
){\cowdoc_dir{cowel_var_delete} \c{mdash} Delete an existing variable}

\pre{
\cowel_highlight_as("markup-tag"){cowel_var_delete}(\cowel_highlight_as("markup-attr"){name}: \cowel_highlight_as("keyword-type"){str}): \cowel_highlight_as("keyword-type"){unit}
}

Deletes the global variable named \cowdoc_attr{name}.
An error is raised if there is no such variable.
