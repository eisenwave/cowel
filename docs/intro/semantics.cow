\h2(id="types-intro"){Types}

While most of the content a user writes tends to be in a markup context,
some is written in a \dfn{scripting context}.
For example, inside the \gterm{group} of a \gterm{directive-splice}.

A scripting context functions similarly to other programming languages,
like JavaScript;
there are values and types,
which can be combined using expressions.

\Bnote{
The capabilities of the scripting context are currently extremely limited,
but should be expanded greatly in the near future.
}

\codeblock(ebnf){\cowel_include_text("type_grammar.ebnf")}

The commas in a \gterm{type-list} act as separators and have no impact on the type.

Note that the type \cowdoc_type{group(int)} is a unambigously a \gterm{prefix-type}
where \cowdoc_type{int} is the only element in the \gterm{type-list},
not a \cowdoc_type{group} \gterm{type-prefix}
followed by an \cowdoc_type{(int)} \gterm{optional-type}.

Also note that in \cowdoc_type{group(int)?},
the \cowdoc_type{?} forms an optional group,
not a group of an optional \cowdoc_type{int}.

\h3{General principles}

The process of converting any union type \math{\mi{U}} into its canonical form
is called \dfn{canonicalization}.
A type is in its \dfn{canonical} form if canonicalization leaves the type unchanged;
otherwise it is in its \dfn{degenerate} form.

Two types are \dfn{equivalent} if they are identical after both are canonicalized.
Equivalent types are semantically the same, but may be spelled differently.

\Bex{
The degenerate union type \cowdoc_type{any | any} is equivalent to \cowdoc_type{any}.
}

\h3{Basic types}

Basic types are the most simple building block of the type system.
They cannot be broken down any further, although some basic types
(namely \cowdoc_type{any} and \cowdoc_type{nothing} are symbolic types).

Canonicalization has no effect for basic types;
they are always in their canonical form.

\h4(id="type-any"){\cowdoc_type{any} \N{EM DASH} Top type}

\cowdoc_type{any} is the root of the type hierarchy,
i.e. every other type is a subtype of \cowdoc_type{any}.
This is also known as a "top type".

\cowdoc_type{any} may be used as a type for parameters and variables,
but there are no value of type \cowdoc_type{any}.

\h4(id="type-nothing"){\cowdoc_type{nothing} \N{EM DASH} Bottom type}

\cowdoc_type{nothing} is a type of which there are no values.
This is also known as a "bottom type".

It is the type of expressions that terminate, i.e. don't return.

\h4(id="type-unit"){\cowdoc_type{unit} \N{EM DASH} Unit type}

\cowdoc_type{unit} is a unit type, i.e. a type with only one possible value
also spelled \cowdoc_type{unit}.

This is used as a result for directives that don't produce any other result.

\h4(id="type-null"){\cowdoc_type{null} \N{EM DASH} Null type}

\cowdoc_type{null} is a unit type with only one possible value
also spelled \cowdoc_type{null}.

\Bnote{
Unlike \cowdoc_type{unit}, \cowdoc_type{null} is used to indicate errors.
}

\h4(id="type-bool"){\cowdoc_type{bool} \N{EM DASH} Boolean type}

\cowdoc_type{bool} is a boolean type.
It can represent two values: \cowdoc_type{true} and \cowdoc_type{false}.

\h4(id="type-int"){\cowdoc_type{int} \N{EM DASH} Integer}

\cowdoc_type{int} is an integer.
It can represent any integer value (although in practice, there is an implementation limit);
this includes negative numbers.

\Bnote{
An \cowdoc_type{int} can be obtained using integer literals
such as \cowdoc_c{123} or \cowdoc_c{0xff}.
}

\h4(id="type-float"){\cowdoc_type{float} \N{EM DASH} 64-bit floating-point number}

\cowdoc_type{float} is a double-precision floating-point number.
That is, a number in \em{binary64} format, as specified in IEEE-754.

\Bnote{
An \cowdoc_type{float} can be obtained using \gterm{float-literal}s
such as \cowdoc_c{1.0} or \cowdoc_c{10e+5}.
}

\h4(id="type-str"){\cowdoc_type{str} \N{EM DASH} String}

\cowdoc_type{str} is a UTF-8 encoded string.

\Bnote{
A value of type \cowdoc_type{str} can be obtained using string literals
such as \cowdoc_c{"abc"}.
}

\h4(id="type-regex"){\cowdoc_type{regex} \N{EM DASH} Regular expression}

\cowdoc_type{regex} is a regular expression.

\Bnote{
A value of type \cowdoc_type{regex} can be obtained using \ref("#dir-cowel_regex").
}

\h4(id="type-block"){\cowdoc_type{block} \N{EM DASH} Block}

\cowdoc_type{block} stores markup elements.
It is very similar to \cowdoc_type{str},
but is evaluated lazily, meaning that it has no effect until spliced.

\Bnote{
A value of type \cowdoc_type{block} can be obtained using block literals
such as \cowdoc_c{{abc}}.
}

\h3{Compound types}

Compound types are formed from other types, possibly from other compound types.

\h4(id="type-group"){\cowdoc_type{group} \N{EM DASH} Product type}

\cowdoc_type{group} combines other types,
called its \dfn{members}, in sequence.
This is also known as a product type.

\Bex{
For example \cowdoc_type{group(int, string)} is group containing an \cowdoc_c{int}
followed by a \cowdoc_type{string}.
A value of such a type can be obtained with the literal \cowdoc_c{(0, "x")}.
}

Canonicalization of a \cowdoc_type{group} \math{\mi{G}} is performed as follows:

\ol{
  \li{
    All members of \math{\mi{G}} are canonicalized.
  }
  \li{
    If any member of \math{\mi{G}} is \cowdoc_type{nothing},
    \math{\mi{G}} is \cowdoc_type{nothing}.
  }
}

\h4(id="type-named"){\cowdoc_type{named} \N{EM DASH} Named group member}

\cowdoc_type{named} is a compound type only nestable
in a \cowdoc_type{group} or \cowdoc_type{pack}.

For example, \cowdoc_type{group named int} is a \cowdoc_type{group}
containing only a single \cowdoc_type{int}.
A value of such a type can be obtained with the literal \cowdoc_c{(x = 0)}.

Canonicalization of a \cowdoc_type{named} \math{\mi{N}} is performed as follows:

\ol{
  \li{
    The nested type of \math{\mi{N}} is canonicalized.
  }
  \li{
    If the nested type of \math{\mi{N}} is \cowdoc_type{nothing},
    \math{\mi{N}} is \cowdoc_type{nothing}.
  }
}

\h4(id="type-pack"){\cowdoc_type{pack} \N{EM DASH} Variadic pack of group members}

\cowdoc_type{pack} is a compound type only nestable in a \cowdoc_type{group}.
It indicates a variadic repetition of the same type.

\Bex{
For example, \cowdoc_type{group pack int}
is a \cowdoc_type{group} containing any amount of \cowdoc_type{int}s.
A value of such a type can be obtained with the literals
\ul{
  \li{\cowdoc_c{(,)} (for an empty group)}
  \li{\cowdoc_c{(1,)} (for a group with a single member),}
  \li{\cowdoc_c{(1,1)} (for a group with two members), etc.}
}
}

Canonicalization of a \cowdoc_type{pack} \math{\mi{P}} is performed as follows:

\ol{
    \li{
      The nested type of \math{\mi{P}} is canonicalized.
    }
    \li{
      If the nested type of \math{\mi{P}} is \cowdoc_type{nothing},
      \math{\mi{P}} is \cowdoc_type{nothing}.
    }
}

\h4(id="type-lazy"){\cowdoc_type{lazy}}

\cowdoc_type{lazy} is a lazily evaluated value.
That is, when specified as a parameter of a directive,
it only gets evaluated when actually needed by that directive.

Canonicalization of a \cowdoc_type{lazy} \math{\mi{L}} is performed
by canonicalizing its nested type.

\h4(id="type-union"){Union}

Unions can be formed by combining other types with \cowdoc_c{|}.
They describe variables and parameters that can hold one of a fixed number of alternatives.
However, a value cannot be of union type.

Alternatives of a union type are subtypes of that union type.
Furthermore, a union type \math{\mi{S}} is a subtype of a union type \math{\mi{U}}
if the set of alternatives of \math{\mi{S}} is a subset of the alternatives of \math{\mi{U}}.

\Bex{
For example, \cowdoc_type{int | str} is a union of
\cowdoc_type{int} and \cowdoc_type{str}.
\cowdoc_type{int} and \cowdoc_type{str} are subtypes of this union,
so a value convertible to this union type can be obtained with
either \cowdoc_c{0} or \cowdoc_c{"x"}.
}

Canonicalization of a \cowdoc_type{union} \math{\mi{U}} is performed as follows:

\ol{
  \li{
    Every alternative of \math{\mi{U}} is canonicalized.
    \math{\mi{U}} is converted to another union type
    where each alternative that is also a union
    is expanded or "flattened" into the top-level union.
    For example, \cowdoc_type{int | (str | bool)}
    is converted to \cowdoc_type{int | str | bool}.
  }
  \li{
    Any \cowdoc_type{nothing} alternatives are removed.
  }
  \li{
    The alternatives are sorted using an unspecified total order of types.
  }
  \li{
    Any duplicate alternatives are removed.
  }
  \li{
    If \math{\mi{U}} now holds a single alternative,
    \math{\mi{U}} is that alternative.
  }
  \li{
    If \math{\mi{U}} now holds no alternatives,
    \math{\mi{U}} is \cowdoc_type{nothing}.
  }
  \li{
    If any alternative of \math{\mi{U}} is \cowdoc_type{any},
    \math{\mi{U}} is \cowdoc_type{any}.
  }
}

\h5{Shorthand notation for optional types (\tt{?})}

The type suffix \cowdoc_type{?} forms a union of the given type and \cowdoc_type{null}.

\Bex{
\cowdoc_type{int?} is equivalent to \cowdoc_type{int | null}.
}

\h3{Splicing}

Values can be spliced into strings and blocks.
For example, \cowdoc_c{"Hello, \\d!"} splices the result of the directive \cowdoc_dir{d}
(with no arguments and no block provided)
into a string,
and \cowdoc_c{{Hello, \\d!}} splices the result of \cowdoc_dir{d} into a block.

Splicing a directive always results in evaluation of that directive.
For example, splicing \cowdoc_dir{cowel_macro} evaluates \cowdoc_dir{cowel_macro},
and its resulting \cowdoc_type{unit} is spliced (resulting in no produced text).

When a value is spliced, it is converted into plaintext.
When splicing into strings, that plaintext simply becomes part of the string content.
For blocks (which are always lazy-evaluated),
splicing means that the resulting plaintext
is fed into the current content policy once the block itself is spliced.

The effect of splicing depends on the type of value:
\ul{
  \li{
    Splicing a value of type \cowdoc_type{unit} produces no characters.
  }
  \li{
    Splicing a value of type \cowdoc_type{null} produces the string \cowdoc_c{"null"}.
  }
  \li{
    Splicing a value of type \cowdoc_type{bool} produces
    \cowdoc_c{"true"} if the value is \cowdoc_type{true}, and
    \cowdoc_c{"false"} otherwise.
  }
  \li{
    Splicing a value of type \cowdoc_type{int} produces
    a string representing the value in decimal form
    without leading zeros.
    For example, the \gterm{int-literal} \cowdoc_c{-015}
    result in '\tt{-15}' when spliced.
  }
  \li{
    Splicing a value of type \cowdoc_type{float} produces
    a string representing the value in decimal form
    as specified below.
  }
  \li{
    Splicing a value of type \cowdoc_type{str} produces
    its string contents.
  }
  \li{
    Splicing a value of type \cowdoc_type{block} splices each markup element within.
  }
  \li{
    Splicing a value of type \cowdoc_type{group} raises an error.
  }
}

\h4(id="splicing-float"){Splicing values of type \cowdoc_type{float}}

Splicing a value \math{\mi{x}} of type \cowdoc_type{float}
is done as follows:

\ul{
  \li{
    If \math{\mi{x}} is a finite value,
    the numeric value in decimal form is produced.
    There are infinitely many such representations;
    one is chosen as follows:
    \ul{
      \li{
        The shortest representation is chosen so that
        when a trailing '\tt{.}' is added (if need be),
        when the representation is interpreted as a
        \gterm{float-literal} optionally preceded by a \gterm{MINUS-TOKEN}
        and then evaluated,
        the same rounded value is recovered.
        Representations with empty integral or fractional part
        adjacent to '\tt{.}' are not eligible.
        Only exponents starting with '\tt{e+}' or '\tt{e-}' are eligible.

        \Bex{\tt{0.1} is chosen over \tt{0.100000000000000005}
        as a representation of the exact value
        \math{\mn{0.1000000000000000055511151231257827021181583404541015625}},
        despite the latter representation having a lower difference.
        \tt{.1} is not chosen because it has an empty integral part.
        
        Both '\tt{1000}' and '\tt{1e+3}' are equally good candidates
        for representing the value \math{\mn{1000}}
        because appending a '\tt{.}' would make the former a valid \gterm{float-literal},
        but this added '\tt{.}' is not counted toward the length.
        }
      }
      \li{
        Then, if there are several such equally long representations,
        the representation with the smallest difference from \math{\mi{x}} is chosen.
        \Bex{\tt{5.038814306823721\mark{5}e+7} is chosen over \tt{5.038814306823721\mark{4}e+7}
        as a representation of the exact value
        \math{\mrow{\mn{5.03881430682372152805328369140625}\mo{Ã—}\msup{\mn{10}\mn{7}}}}.}
      }
      \li{
        Then, if there are several such equidistant representations
        of which both or neither have an \gterm{exponent},
        ties are broken as if by roundTiesToEven as specified in IEEE-754.
        \Bex{\tt{1125899906842624.2} is chosen over \tt{1125899906842624.3}
        as a representation of the exact value
        \math{\mn{1125899906842624.25}}.}
      }
      \li{
        Then, if there are several such representations of zero distance,
        the one without an \gterm{exponent} is chosen.
        \Bex{\tt{1000} is chosen over \tt{1e+3} as a representation of \math{\mn{1000}}.
        The previous step does not yet favor '\tt{1000}' due to having an even
        least significant digit.}
      }
      \li{
        Then, if both have an \gterm{exponent},
        the one with the greater exponent value is chosen.
        \Bex{\tt{1e+10} is chosen over \tt{10e+9}
        as a representation of \math{\msup{\mn{10}\mn{9}}}.}
      }
    }
    All negative values are represented with a leading \cowdoc_cp(0x2D),
    including negative zero.
  }
  \li{
    Otherwise, if \math{\mi{x}} is positive infinity,
    '\tt{infinity}' is produced.
  }
  \li{
    Otherwise, if \math{\mi{x}} is negative infinity,
    '\tt{-infinity}' is produced.
  }
  \li{
    Otherwise, if \math{\mi{x}} is NaN,
    '\tt{NaN}' is produced.
  }
}

\Bnote{
The result has at most 17 significant decimal digits;
this is sufficient to represent any double-precision floating-point number.
The produced output is at most 24 characters long
(including the radix point, exponent separator, and 4 exponent digits).

See also \url{https://www.exploringbinary.com/the-shortest-decimal-string-that-round-trips-examples/}
}


\comment{
\h3{Type checking}

Values always have a type,
regardless of whether those are specified for variables.
Type annotations can be added optionally and are checked at the earliest opportunity.
Depending on the situation,
this either happens when a function is declared or when it is evaluated:

\cowblock{
\\: Checked immediately
val s = "awoo"
val x: int = s

\\: Checked during evaluation
val s_or_i: str | int = "awoo"
val y: int = s_or_i
}

In the initialization of \cowdoc_c{x},
a variable of type \cowdoc_type{int} is initialized
with an expression of type \cowdoc_type{str}.
There exist no possible evaluation where this is valid,
so an error is raised immediately.

In the initialization of \cowdoc_c{y},
the expression \cowdoc_c{s_or_i} is of type \cowdoc_type{str | int},
and there exists a hypothetical evaluation
where \cowdoc_c{s_or_i} holds an \cowdoc_type{int},
so no error is raised immediately.
However, when the function is evaluated,
\cowdoc_c{s_or_i} always holds a \cowdoc_type{str},
so an error is raised when initializing \cowdoc_c{y}.

In any case, it is checked that \cowdoc_c{y} holds an \cowdoc_type{int};
this condition cannot be violated.
}

