\h2{Syntax}

At the document level,
COWEL has a minimalistic but powerful syntax,
built on top of only a few \dfn{markup elements}:
\ul{
  \li{\cowdoc_c{Text.}}
  \li{Escape sequences, such as \cowdoc_c{\\\U(0x7B)}, \cowdoc_c{\\\U(0x7D)}, \cowdoc_c{\\\\}, etc.}
  \li{\cowdoc_c{\\: line comments}}
  \li{\cowdoc_c{\\* block comments *\\}}
  \li{\cowdoc_c{\\directive_splices(positional, args, named_args = 0){and content}}}
}

These are what a user writes most of the time.

Formally, COWEL documents is processed in several phases:
\ol{
  \li{
    The UTF-8-encoded source code is decoded into a sequence of code points.
  }
  \li{
    The code points are partitioned into \dfn{tokens}.
    See \ref("#lexical-analysis").
  }
  \li{
    A syntax tree is formed from the tokens.
    See \ref("#parsing").
  }
}

\Bnote{
At the top-level in the \gterm{DOCUMENT},
there are no other syntactical features,
meaning that as long as some bit of code doesn't contain a \cowdoc_cp(0x5C),
it's all interpreted as plaintext.
This makes COWEL exceptionally suited to nest other languages inside of it in code blocks etc.
}

\h3{Lexical analysis}

The code points of the COWEL source code are partitioned into tokens.
This occurs as specified by a
\ref("https://en.wikipedia.org/wiki/Nested_word"){Visibly Pushdown Language}.

\Bnote{
A Visibly Pushdown Language is a superset of Regular Language;
it additionally contains constructs like matching pairs of braces and parentheses.
}

Formally, in \ref("https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"){EBNF}
grammar format,
a \gterm{DOCUMENT} is matched as follows:

\codeblock(ebnf){\cowel_include_text("lex_grammar.ebnf")}

Let the \dfn{tokens} of the document be any matched nonterminals
whose name ends with \gterm{TOKEN}.

After matching the input source code according to the grammar above,
the following post-processing steps take place:

\ol{
  \li{
    If any token was matched whose names starts with \gterm{RESERVED},
    an error is raised,
    and processing is abandoned.
  }
  \li{
    Any
    \gterm{LINE-COMMENT-TOKEN},
    \gterm{BLOCK-COMMENT-TOKEN}, or
    \gterm{WHITESPACE-TOKEN}
    that is \gterm{GROUP-CONTENT} is discarded.
  }
}

\Bnote{
The purpose of \gterm{RESERVED} tokens is to specify error handling.
These tokens are matched when no other valid token may be formed,
and any software processing COWEL should attempt to form these tokens.
}

\h4{Text}

\dfn{Text} (such as \gterm{DOCUMENT-TEXT-TOKEN} in the grammar)
is a markup element which consists of as many characters as possible,
excluding \cowdoc_cp(0x5C).

\codeblock(ebnf){
DOCUMENT-TEXT-TOKEN
  = DOCUMENT-TEXT-CHAR, { DOCUMENT-TEXT-CHAR };
DOCUMENT-TEXT-CHAR
  = CHAR - "\\";
}

\Bnote{
In most situations, text is not processed specially.
However, the output may depend on the context (\ref("#contexts-and-output")).
For example, \cowdoc_c{<} in text will render as a < character,
but will be converted to \cowdoc_html{&lt;} when fed into a To-HTML Policy.
Furthermore, text is subject to special effects like syntax highlighting
and paragraph splitting.
}

\h4{Whitespace}

COWEL translates text in whitespace directly into HTML in most situations.
Additional styling with CSS can be applied
to interpret that whitespace literally (like in \cowdoc_html{<pre>} elements)
or to have it merged into spaces,
which happens by default.

At the document top-level,
\ref("#paragraph-splitting") takes place.

\Bex{
COWEL markup:
\cowblock{
This displays on one line
because line breaks render like spaces.
}
Generated HTML:
\htmlblock{
<p>This displays on one line
because line breaks render like spaces.</p>
}
Rendered output:
\Bindent{This displays on one line because line breaks render like spaces.}
}

\h4{Escape sequences}

COWEL supports multiple escape sequences,
all of which begin with a \cowdoc_c{\\} (like directives),
but are followed by some special character.
The meaning of the escape sequences is described in the table below.

\style{
  #escapes-table {
    margin-left:auto;
    margin-right:auto;
    table-layout: fixed;
  }
  #escapes-table td {
    border-top: 1px solid var(--border-color);
  }
  #escapes-table td:first-child {
    width: 40%;
  }
}

\table(id="escapes-table"){
  \tr{
    \th{Escape sequence}
    \th{Meaning}
  }
  \tr{
    \td{
      \cowdoc_esc{\N{LEFT CURLY BRACKET}},
      \cowdoc_esc{\N{RIGHT CURLY BRACKET}},
      \cowdoc_esc{\\},
      \cowdoc_esc{"},
    }
    \td{
      Expands to the second character in the escape sequence.
    }
  }
  \tr{
    \td{
      \nobr{\cowdoc_esc U+000A LINE FEED},
      \nobr{\cowdoc_esc U+000D CARRIAGE RETURN},
      \nobr{\cowdoc_esc U+000A U+000D (CRLF escape)}
    }
    \td{
      Expands to nothing.
    }
  }
}

In EBNF grammar, an \gterm{ESCAPE-TOKEN} is constructed like:

\codeblock(ebnf){
ESCAPE-TOKEN
  = "\", ESCAPABLE-CHAR
  | "\", LINE-TERMINATOR;
ESCAPABLE-CHAR
  = "{" |  "}" | '"' | "\";
LINE-TERMINATOR
  = LF
  | CR, LF
  | CR ? not followed by LF ?;
}

\Bnote{
The purpose of most escapes is to prevent a character from having special meaning.
For example, the \cowdoc_esc{"} escape prevents a quote
from being interpreted as the end of a \gterm{QUOTED-STRING}.

The purpose of the newline escapes is to remove unwanted newlines
and to join long content that spans multiple lines,
but without introducing any whitespace in the markup.
}

\h4(id="syntax-comments"){Comments}

There are two types of comments:
line comments and block comments.

\h5{Line comments}

Line comments begin with \cowdoc_c{\\:} and extend until the end of the line.
In almost every context,
comments are discarded instead of being emitted into the output HTML.

This makes them useful for adding information to the COWEL markup.

\Bnote{
A \gterm{LINE-COMMENT-TOKEN}, just like any other content,
is actually part of the AST and doesn't simply get discarded during parsing.
This means that a \gterm{LINE-COMMENT-TOKEN} wrapped in \ref("#dir-cowel_source_as_text")
will render as expected:
\cowblock{\cowel_source_as_text{
\cowel_source_as_text{A\: A comment ...
B}
}}
Generated HTML:
\htmlblock{
\cowel_source_as_text{A\: A comment ...
B}
}
}

In EBNF grammar, a \gterm{LINE-COMMENT-TOKEN} is constructed as follows:

\codeblock(ebnf){
LINE-COMMENT-TOKEN
  = "\\:", { LINE-COMMENT-CHAR }, LINE-TERMINATOR;
LINE-COMMENT-CHAR
  = CHAR - (LF | CR);
}

Comments include a \gterm{LINE-TERMINATOR},
which means that a trailing \gterm{LINE-COMMENT-TOKEN} won't add any lines (not even blank lines)
to the generated markup.

\Bex{
We can even join words by putting a \gterm{line-comment} between:
\cowblock{\literally{
Hello\: this comment will absorb the newline
World

Hello \: this comment also does, but is preceded by a space
World
}}

Generated HTML:
\htmlblock{
HelloWorld

Hello World
}
}

\h5{Block comments}

A block comment functions exactly the same as a line comment,
but is terminated at a point of choice instead of at the end of the line.

\Bex{
COWEL markup:
\cowblock{
A\\* comment in the middle *\\B
}
Generated HTML:
\htmlblock{
AB
}
}

In EBNF grammar, a \gterm{BLOCK-COMMENT-TOKEN} is constructed as follows:

\codeblock(ebnf){
BLOCK-COMMENT-TOKEN
  = "\\*", { BLOCK-COMMENT-CHAR }, "*\\";
BLOCK-COMMENT-CHAR
  = CHAR - ("*" ? followed by "\\" ?);
}

\Bnote{
\gterm{BLOCK-COMMENT-TOKEN}s do not allow nesting,
meaning that '\cowdoc_c{\\:}' or '\cowdoc_c{\\*}'
inside of a \gterm{BLOCK-COMMENT-TOKEN} has no special meaning.

Similarly, '\cowdoc_c{\\*}' has no special meaning
inside of a \gterm{LINE-COMMENT-TOKEN}.
}

\h4{Literals}

Inside scripting contexts such as in directive arguments,
\gterm{GROUP-CONTENT} may appear,
some of which represents a value of a basic type (\ref("#types-intro")).

\codeblock(ebnf){
GROUP-CONTENT
  = GROUP
  | BLOCK
  | IDENTIFIER-TOKEN
  | QUOTED-STRING
  | BINARY-INT-TOKEN
  | OCTAL-INT-TOKEN
  | DECIMAL-INT-TOKEN
  | HEXADECIMAL-INT-TOKEN
  | DECIMAL-FLOAT-TOKEN
  | INFINITY-TOKEN
  | NEGATIVE-INFINITY-TOKEN
  | EQUALS-TOKEN
  | COMMA-TOKEN
  | ELLIPSIS-TOKEN
  | UNIT-TOKEN
  | NULL-TOKEN
  | TRUE-TOKEN
  | FALSE-TOKEN
  | LINE-COMMENT-TOKEN
  | BLOCK-COMMENT-TOKEN
  | WHITESPACE-TOKEN
  | RESERVED-NUMBER-TOKEN;
}

Some literals are simply keywords:

\ul{
  \li{
    The literal \cowdoc_c{unit} represents the value of type \cowdoc_type{unit}
    (\ref("#type-unit")).
  }
  \li{
    The literal \cowdoc_c{null} represents the value of type \cowdoc_type{null}
    (\ref("#type-null")).
  }
  \li{
    The literals \cowdoc_c{true} and \cowdoc_c{false} represent values of type \cowdoc_type{bool}
    (\ref("#type-bool")).
  }
}

\h4(id="int-literal"){\gterm{int-literal} \N{EM DASH} Integer literal}

\codeblock(ebnf){
int-literal
  = BINARY-INT-TOKEN
  | OCTAL-INT-TOKEN
  | DECIMAL-INT-TOKEN
  | HEXADECIMAL-INT-TOKEN;
BINARY-INT-TOKEN
  = [ "-" ], "0B", BINARY-DIGIT, { BINARY-DIGIT };
OCTAL-INT-TOKEN
  = [ "-" ], "0O", OCTAL-DIGIT, { OCTAL-DIGIT };
DECIMAL-INT-TOKEN
  = [ "-" ], DIGIT, { DIGIT };
HEXADECIMAL-INT-TOKEN
  = [ "-" ], "0X", HEXADECIMAL-DIGIT, { HEXADECIMAL-DIGIT };
BINARY-DIGIT
  = "0" | "1";
OCTAL-DIGIT
  = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
HEXADECIMAL-DIGIT
  = DIGIT
  | "A" | "B" | "C" | "D" | "E" | "F"
  | "a" | "b" | "c" | "d" | "e" | "f";
}

The tokens listed above are later matched by an \gterm{int-literal},
and represent a value of type \cowdoc_type{int}
(\ref("#type-int")).

The \dfn{base} \math{\mi{B}} of a \gterm{int-literal} is
\ul{
  \li{\math{\mn{2}} for a \gterm{BINARY-INT-TOKEN},}
  \li{\math{\mn{8}} for an \gterm{OCTAL-INT-TOKEN},}
  \li{\math{\mn{10}} for an \gterm{DECIMAL-INT-TOKEN}, and}
  \li{\math{\mn{16}} for an \gterm{HEXADECIMAL-INT-TOKEN}.}
}
The value is of an \gterm{int-literal} in base \math{\mi{B}}
is determined by interpreting each digit from left to right
as decimal digits of a base-\math{\mi{B}} integer,
from most significant to least significant.
The \gterm{HEXADECIMAL-DIGIT}s \tt{a..f} and \tt{A..F} both represent
digits of value \math{\mn{10}}..\math{\mn{15}}.

Leading zeros are ignored.
The value is negative if the leading \cowdoc_cp(0x2D) is present.

\Bex{
The \gterm{int-literal} \cowdoc_c{-0123} represents the integer value
\math{\mrow{\mo(form=prefix){−}\mn{123}}}.

The \gterm{BINARY-INT-TOKEN} \cowdoc_c{0b11111111},
the \gterm{OCTAL-INT-TOKEN} \cowdoc_c{0o377},
the \gterm{DECIMAL-INT-TOKEN} \cowdoc_c{255}, and
the \gterm{HEXADECIMAL-INT-TOKEN} \cowdoc_c{0xff}
all represent the value \math{\mn{255}}.
}

\h4(id="float-literal"){\gterm{float-literal} \N{EM DASH} Floating-point literal}

\codeblock(ebnf){
float-literal
  = INFINITY-TOKEN
  | NEGATIVE-INFINITY-TOKEN
  | DECIMAL-FLOAT-TOKEN;
INFINITY-TOKEN
  = "infinity" ? not followed by IDENTIFIER-CHAR ?;
NEGATIVE-INFINITY-TOKEN
  = "-infinity;" ? not followed by IDENTIFIER-CHAR ?;
DECIMAL-FLOAT-TOKEN
  = DECIMAL-FLOAT ? not followed by IDENTIFIER-CHAR ?;
DECIMAL-FLOAT
  = [ "-" ], DIGIT, { DIGIT }, ".", { DIGIT }, [ EXPONENT ]
  | [ "-" ], ".", DIGIT, { DIGIT }, [ EXPONENT ]
  | [ "-" ], DIGIT, { DIGIT }, EXPONENT;
EXPONENT
  = ("e" | "E"), [ "+" | "-" ], DIGIT, { DIGIT };
}

A \gterm{float-literal} represents a value of type \cowdoc_type{float}
(\ref("#type-float")).

The value of '\tt{-infinity}' is negative infinity, and
the value of '\tt{infinity}' is positive infinity.

A \gterm{DECIMAL-FLOAT-TOKEN} consists of several parts:
\ul{
  \li{
    An \dfn{integral part}, either matching a \gterm{int-literal}
    or consisting of only a leading \cowdoc_cp(0x2D),
    which is equivalent to '\tt{-0}'.
  }
  \li{
    The radix point \cowdoc_cp(0x2E).
  }
  \li{
    A \dfn{fractional part} consisting of \gterm{digit}s following the radix point.
    An absent fractional part is equivalent to '\tt{0}'.
  }
  \li{
    An \gterm{exponent}.
  }
}

The value of a \gterm{DECIMAL-FLOAT-TOKEN} is determined as follows:

\ol{
  \li{
    Let \math{\mi{s}} be -1 if the leading \cowdoc_cp(0x2D) is present,
    otherwise 1;
    let \math{\mi{k}} be the integer value of the integral part
    (determined as for a \gterm{int-literal});
    let \math{\mi{f}} be the the integer value of the fractional part;
    let \math{\mi{p}} be the amount of digits including leading zeros of the fractional part;
    let \math{\mi{e}} be the integer value of the exponent.
  }
  \li{
    Let the \dfn{scaled value} of the \gterm{DECIMAL-FLOAT-TOKEN} be
    \mathblock{\mrow{
      \mi{s}
      \mo{×}
      \mo{\N{LEFT PARENTHESIS}}
      \mi{k}
      \mo{+}
      \mfrac{\mi{f}\msup{\mn{10}\mi{p}}}
      \mo{\N{RIGHT PARENTHESIS}}
      \mo{×}
      \msup{\mn{10}\mi{e}}
    }}
  }
  \li{
    The value of the \gterm{DECIMAL-FLOAT-TOKEN} is the scaled value,
    rounded using the roundTiesToEven rounding direction
    as specified in IEEE-754,
    except that subnormal inexact values are never "flushed" to zero.
  }
}

\Bex{
\ul{
  \li{\cowdoc_c{1.0} exactly represents the value 1.0.}
  \li{\cowdoc_c{.1} is rounded to a value nearest to 0.1.}
  \li{\cowdoc_c{1e1000000} is rounded to positive infinity.}
  \li{\cowdoc_c{-1e1000000} is rounded to negative infinity.}
  \li{\cowdoc_c{1e-1000000} is rounded to positive zero.}
  \li{\cowdoc_c{-1e-1000000} is rounded to negative zero.}
  \li{\cowdoc_c{-0.0} exactly represents a negative zero.}
}
}

\:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

\h3{Parsing}

After lexical analysis,
the produced tokens are used as the input to the parsing stage.
The tokens from lexical analysis are matched by a context-free grammar as follows:

\codeblock(ebnf){\cowel_include_text("grammar.ebnf")}

\h3{Directives splices}

A \dfn{directive} is a way of generating plaintext, HTML, both, or neither.
You can think of it as a "command" or "function call".

\dfn{Splicing} means to evaluate a directive (or something else, in the future)
and to insert the result between the surrounding markup elements.
Splicing consists of three steps:

\ol{
  \li{
    Looking up the name of the spliced directive.
  }
  \li{
    Evaluating the directive (and its arguments, if any).
    Evaluation of the directive usually produces a result.
    This may not happen when evaluation raises an error.
  }
  \li{
    Feeding the result into the current content policy (\ref("#contexts-and-output")).
  }
}

\Bex{
COWEL markup:
\cowblock{\literally{
1 + 2 + 3 = \cowel_add(1, 2, 3)
}}
Generated HTML:
\htmlblock{
1 + 2 + 3 = \cowel_add(1, 2, 3)
}
As explained, this markup is processed in three steps:
\ol{
  \li{
    \cowdoc_dir{cowel_add} is looked up by name.
    This succeeds because \cowdoc_dir{cowel_add} is a builtin directive.
  }
  \li{
    The three arguments (of type \cowdoc_type{int}) to \cowdoc_dir{cowel_add}
    are evaluated,
    and \cowdoc_dir{cowel_add} itself is evaluated,
    which produces a value \cowdoc_c{6} of type \cowdoc_type{int}.
  }
  \li{
    The resulting value \cowdoc_c{6} is fed as plaintext
    into the surrounding content policy,
    which usually results in a single \cowdoc_cp(0x36) character being output.
  }
}
}

Every directive has three parts:
\ul{
  \li{
    The \cowdoc_c{\\directive_name} selects a specific directive to be processed.
  }
  \li{
    An optional \cowdoc_c{\cowel_highlight_phantom{\\d}\
(comma-separated, positional, arguments, named-arguments = ...)}
    group provides additional inputs to the directive.
  }
  \li{
    An optional \cowdoc_c{\cowel_highlight_phantom{\\d}{block of content}}
    provides a "main input" to a directive.
  }
}

In EBNF grammar, a \gterm{directive-splice} is constructed as follows:

\codeblock(ebnf){
directive-splice
  = DIRECTIVE-SPLICE-NAME-TOKEN, [ group ], [ block ];
DIRECTIVE-SPLICE-NAME-TOKEN
  = "\", IDENTIFIER-TOKEN;
}

\h4{Directive names}

A \dfn{directive name} selects a specific directive to be processed.
The name begins with a \cowdoc_cp(0x5C) character,
followed by a sequence of ASCII alphanumeric characters or \cowdoc_cp(0x5F).
However, the first character after \cowdoc_cp(0x5C) cannot be an ASCII digit.

\Btip{
You can use an empty block of content to "cut a name short":
\cowblock{
Thisisavery\\wbr{}longword.
}
Doing so is equivalent to writing
\cowdoc_c{\\wbr} and \cowdoc_c{longword} immediately following one another.
}

\h4{Directive arguments}

Grammatically, the arguments are a \gterm{group},
which is constructed as follows:

\codeblock(ebnf){
group
  = PARENTHESIS-LEFT-TOKEN, [ group-member-list ], PARENTHESIS-RIGHT-TOKEN;
group-member-list
  = group-member, { COMMA-TOKEN, group-member }, [ COMMA-TOKEN ];
group-member
  = member-name, EQUALS-TOKEN, member-value
  | member-value
  | ELLIPSIS-TOKEN;
member-name
  = identifier
  | quoted-string;
}

\dfn{Directive arguments} can be
\dfn{positional arguments},
\dfn{named arguments}, or
\dfn{ellipses}.
Arguments are separated by commas.

\Bex{
Often, arguments are converted to HTML attributes.
\cowblock{
\\b(id = abc){Bold text.}
}
Generated HTML:
\htmlblock{
<b id=abc>Bold text.</b>
}
}

\h5{Named arguments}

A \dfn{named argument} is a \gterm{group-member} of the form
\cowdoc_c{\cowel_highlight_phantom{\\d\N{LEFT PARENTHESIS}}name = value},
where spaces anywhere around \cowdoc_attr{name} and \cowdoc_c{value} are ignored.
Named arguments are matched to directive parameters before any positional arguments,
meaning that positional arguments fill the remaining unmatched arguments.

Argument names can consist of any character, except
ASCII control characters,
U+0020\c{nbsp}SPACE,
\cowdoc_cp(0x22),
\cowdoc_cp(0x27),
\cowdoc_cp(0x2C),
\cowdoc_cp(0x2F),
\cowdoc_cp(0x3D),
\cowdoc_cp(0x3E),
\cowdoc_cp(0x5B),
\cowdoc_cp(0x5C),
\cowdoc_cp(0x5D),
\cowdoc_cp(0x7B),
\cowdoc_cp(0x7D),
and noncharacters.

\Btip{
If you want to provide a positional argument that is \cowdoc_c{name = value} instead,
you can do so by writing:
\cowblock{\literally{
\: "name = value" as a positional argument
\xyz("name = value")
\: named argument with name "name" and value "value"
\xyz(name = value)
}}
Only the literal \cowdoc_c{=} character can be used for named arguments,
not its escaped variant \cowdoc_c{\\=}.
}

\h5{Positional arguments}

A \dfn{positional argument} is a \gterm{group-member} of the form
\gterm{member-value}.

Positional arguments are content just like any other content,
except that an unbalanced closing \cowdoc_cp(0x5D) or a \cowdoc_cp(0x2C)
ends the content.

\h5{Ellipses}

An \dfn{ellipsis argument} is a \gterm{group-member}
spelled \ellipsis.
Ellipsis arguments are placeholders which expand to arguments provided to a surrounding macro.
See also \ref("#dir-cowel_macro") and \ref("#dir-cowel_put").

\Bex{
COWEL markup:
\cowblock{\literally{
\: Define a macro for generating <div> elements
\cowel_macro(div){\cowel_html_element(div, attr = (...)){\cowel_put}}

\div(id = abc){inner text}
}}
Generated HTML:
\htmlblock{
<div id=abc>inner text</div>
}
}

Specifically, any positional argument which begins with \ellipsis
(ignoring leading whitespace and comments)
is considered an ellipsis.
The text \tt{...} is not considered an ellipsis if it appears anywhere else
or has preceding content within an argument.

An error is raised if an ellipsis is used as an argument outside of a macro expansion.

\Bex{
\cowblock{\literally{
\m("...") \: OK, providing string "...", not an ellipsis
\m(...)   \: error: ellipsis is not expanded from a macro
}}
}

\h5{Groups}

Groups make it possible to group any of the aforementioned constructs.
Groups begin with \code(cowel){\cowel_highlight_phantom{\\d}\N{LEFT PARENTHESIS}}
and end with \code(cowel){\cowel_highlight_phantom{\\d\N{LEFT PARENTHESIS}}\N{RIGHT PARENTHESIS}}.
They can appear both in positional and in named arguments.

\Bex{
\codeblock(cowel){\literally{
\d((x), (), (y,))    \: groups as positional arguments
\d(n = (x, y))       \: group as named argument
\d(((())))           \: nested empty groups
}}
}

\Bwarn{
In the future, parentheses surrounding a single positional argument
will be treated as (ignored) parentheses around an expression,
like in typical programming languages.

For a group containing a single positional member,
\cowdoc_c{(x,)} may also be used.
That is, the trailing comma can only be used in a group,
not in an expression,
so it acts as a disambiguator.
}

\h4{Directive content}

The \dfn{directive content} is the primary input to a directive.
It is delimited by a '\tt{\{}' and ends with a \em{matching} closing '\tt{\}}'.
This means that you can have opening and closing braces inside text,
but they need to be balanced.

\Bex{
COWEL markup:
\cowblock{
\\b{Bold text { with braces }.}
}
Generated HTML:
\htmlblock{
<b>Bold text { with braces }.</b>
}
}

Escape sequences don't participate in this "brace matching",
so they can be used to literally produce a brace character.
\Bex{
COWEL markup:
\cowblock{
\\b{Bold text \\\U(0x7B) with brace.}
}
Generated HTML:
\htmlblock{
<b>Bold text \U(0x7B) with brace.</b>
}
}

Unlike in the directive arguments,
whitespace is not trimmed.
\Bex{
COWEL markup:
\cowblock{
\\b{bold} \\i{ italic }
}
Generated HTML:
\htmlblock{
<b>bold</b> <i> italic </i>
}
}

\Bnote{
Only one such block of content can be provided, unlike in TeX,
which has a similar syntax,
but permits multiple blocks. Each block is separated by a pair of braces.
}

