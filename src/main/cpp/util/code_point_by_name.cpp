#include <algorithm>
#include <string>
#include <string_view>
#include <vector>

#include "cowel/util/assert.hpp"
#include "cowel/util/chars.hpp"
#include "cowel/util/code_point_names.hpp"
#include "cowel/util/from_chars.hpp"

#include "code_point_by_name_autogenerated.cpp.txt"

using namespace llvm;
using namespace llvm::sys::unicode;

using BufferType = std::string;
using StringRef = std::string_view;
using std::uint16_t;
using std::uint32_t;
using std::uint8_t;

namespace llvm {
namespace {

[[nodiscard]]
constexpr bool isAlnum(char c)
{
    // https://github.com/llvm/llvm-project/blob/5f5560f62bfbaf3b38c90ae926fd07463ab74b8e/libc/src/__support/ctype_utils.h#L304
    return cowel::is_ascii_alphanumeric(char8_t(c));
}

[[nodiscard]]
constexpr char toUpper(char c)
{
    // https://github.com/llvm/llvm-project/blob/5f5560f62bfbaf3b38c90ae926fd07463ab74b8e/llvm/include/llvm/ADT/StringExtras.h#L171
    return char(cowel::to_ascii_upper(char8_t(c)));
}

[[nodiscard]]
constexpr bool getAsUnsignedInteger(StringRef Str, unsigned Radix, unsigned long long& Result)
{
    // https://github.com/llvm/llvm-project/blob/5f5560f62bfbaf3b38c90ae926fd07463ab74b8e/llvm/lib/Support/StringRef.cpp#L482
    const auto [p, ec] = cowel::from_characters(Str, Result, int(Radix));
    return ec != std::errc {} || p != Str.data() + Str.size();
}

[[nodiscard]]
constexpr char hexdigit(unsigned X, bool LowerCase = false)
{
    // https://github.com/llvm/llvm-project/blob/5f5560f62bfbaf3b38c90ae926fd07463ab74b8e/llvm/include/llvm/ADT/StringExtras.h#L38
    COWEL_DEBUG_ASSERT(X < 16);
    static constexpr char LUT[] = "0123456789ABCDEF";
    const uint8_t Offset = LowerCase ? 32 : 0;
    return char(LUT[X] | Offset);
}

[[nodiscard]]
inline std::string utohexstr(uint64_t X, bool LowerCase = false, unsigned Width = 0)
{
    // https://github.com/llvm/llvm-project/blob/5f5560f62bfbaf3b38c90ae926fd07463ab74b8e/llvm/include/llvm/ADT/StringExtras.h#L177
    char Buffer[17];
    char* BufPtr = std::end(Buffer);

    if (X == 0 && !Width) {
        *--BufPtr = '0';
    }

    for (unsigned i = 0; Width ? (i < Width) : X; ++i) {
        unsigned char Mod = static_cast<unsigned char>(X) & 15;
        *--BufPtr = hexdigit(Mod, LowerCase);
        X >>= 4;
    }

    return { BufPtr, std::end(Buffer) };
}

[[nodiscard]]
constexpr bool contains_insensitive(StringRef Self, StringRef Other)
{
    // https://github.com/llvm/llvm-project/blob/5f5560f62bfbaf3b38c90ae926fd07463ab74b8e/llvm/include/llvm/ADT/StringRef.h#L438
    constexpr auto equals_insensitive = [](StringRef x, StringRef y) {
        if (x.length() != y.length()) {
            return false;
        }
        for (std::size_t i = 0; i < x.length(); ++i) {
            if (toUpper(x[i]) != toUpper(y[i])) {
                return false;
            }
        }
        return true;
    };

    if (Other.empty()) {
        return true;
    }
    for (std::size_t i = 0; i + Other.length() <= Self.length(); ++i) {
        if (equals_insensitive(Self.substr(i, Other.length()), Other)) {
            return true;
        }
    }
    return false;
}

} // namespace
} // namespace llvm

namespace cowel {
namespace {

struct Node {
    bool IsRoot = false;
    char32_t Value = 0xFFFFFFFF;
    uint32_t ChildrenOffset = 0;
    bool HasSibling = false;
    uint32_t Size = 0;
    StringRef Name;
    const Node* Parent = nullptr;

    [[nodiscard]]
    constexpr bool isValid() const
    {
        return !Name.empty() || Value == 0xFFFFFFFF;
    }
    [[nodiscard]]
    constexpr bool hasChildren() const
    {
        return ChildrenOffset != 0 || IsRoot;
    }

    [[nodiscard]]
    std::string fullName() const
    {
        std::string S;
        // Reserve enough space for most unicode code points.
        // The chosen value represent the 99th percentile of name size as of
        // Unicode 15.0.
        S.reserve(46);
        const Node* N = this;
        while (N) {
            std::ranges::reverse_copy(N->Name, std::back_inserter(S));
            N = N->Parent;
        }
        std::ranges::reverse(S);
        return S;
    }
};

[[nodiscard]]
Node createRoot()
{
    Node N;
    N.IsRoot = true;
    N.ChildrenOffset = 1;
    N.Size = 1;
    return N;
}

[[nodiscard]]
Node readNode(uint32_t Offset, const Node* Parent = nullptr)
{
    if (Offset == 0) {
        return createRoot();
    }

    uint32_t Origin = Offset;
    Node N;
    N.Parent = Parent;
    uint8_t NameInfo = UnicodeNameToCodepointIndex[Offset++];
    if (Offset + 6 >= UnicodeNameToCodepointIndexSize) {
        return N;
    }

    bool LongName = NameInfo & 0x40;
    bool HasValue = NameInfo & 0x80;
    std::size_t Size = NameInfo & ~0xC0;
    if (LongName) {
        auto NameOffset = uint32_t(UnicodeNameToCodepointIndex[Offset++] << 8);
        NameOffset |= UnicodeNameToCodepointIndex[Offset++];
        N.Name = StringRef(UnicodeNameToCodepointDict + NameOffset, Size);
    }
    else {
        N.Name = StringRef(UnicodeNameToCodepointDict + Size, 1);
    }
    if (HasValue) {
        uint8_t H = UnicodeNameToCodepointIndex[Offset++];
        uint8_t M = UnicodeNameToCodepointIndex[Offset++];
        uint8_t L = UnicodeNameToCodepointIndex[Offset++];
        N.Value = char32_t((H << 16) | (M << 8) | L) >> 3;

        bool HasChildren = L & 0x02;
        N.HasSibling = L & 0x01;

        if (HasChildren) {
            N.ChildrenOffset = uint32_t(UnicodeNameToCodepointIndex[Offset++] << 16);
            N.ChildrenOffset |= uint32_t(UnicodeNameToCodepointIndex[Offset++] << 8);
            N.ChildrenOffset |= UnicodeNameToCodepointIndex[Offset++];
        }
    }
    else {
        uint8_t H = UnicodeNameToCodepointIndex[Offset++];
        N.HasSibling = H & 0x80;
        bool HasChildren = H & 0x40;
        H &= uint8_t(~0xC0);
        if (HasChildren) {
            N.ChildrenOffset = uint32_t(H << 16);
            N.ChildrenOffset |= (uint32_t(UnicodeNameToCodepointIndex[Offset++]) << 8);
            N.ChildrenOffset |= UnicodeNameToCodepointIndex[Offset++];
        }
    }
    N.Size = Offset - Origin;
    return N;
}

[[nodiscard]]
bool startsWith(
    StringRef Name,
    StringRef Needle,
    bool Strict,
    std::size_t& Consummed,
    char& PreviousCharInName,
    bool IsPrefix = false
)
{

    Consummed = 0;
    if (Strict) {
        if (!Name.starts_with(Needle)) {
            return false;
        }
        Consummed = Needle.size();
        return true;
    }
    if (Needle.empty()) {
        return true;
    }

    auto NamePos = Name.begin(); // NOLINT(readability-qualified-auto)
    auto NeedlePos = Needle.begin(); // NOLINT(readability-qualified-auto)

    char PreviousCharInNameOrigin = PreviousCharInName;
    char PreviousCharInNeedle = *Needle.begin();
    auto IgnoreSpaces = [](auto It, auto End, char& PreviousChar, bool IsPrefix = false) {
        while (It != End) {
            const auto Next = std::next(It);
            // Ignore spaces, underscore, medial hyphens
            // The generator ensures a needle never ends (or starts) by a medial
            // hyphen https://unicode.org/reports/tr44/#UAX44-LM2.
            bool Ignore = *It == ' ' || *It == '_'
                || (*It == '-' && isAlnum(PreviousChar)
                    && ((Next != End && isAlnum(*Next)) || (Next == End && IsPrefix)));
            PreviousChar = *It;
            if (!Ignore) {
                break;
            }
            ++It;
        }
        return It;
    };

    while (true) {
        NamePos = IgnoreSpaces(NamePos, Name.end(), PreviousCharInName);
        NeedlePos = IgnoreSpaces(NeedlePos, Needle.end(), PreviousCharInNeedle, IsPrefix);
        if (NeedlePos == Needle.end()) {
            break;
        }
        if (NamePos == Name.end()) {
            break;
        }
        if (toUpper(*NeedlePos) != toUpper(*NamePos)) {
            break;
        }
        NeedlePos++;
        NamePos++;
    }
    Consummed = std::size_t(std::distance(Name.begin(), NamePos));
    if (NeedlePos != Needle.end()) {
        PreviousCharInName = PreviousCharInNameOrigin;
    }
    return NeedlePos == Needle.end();
}

[[nodiscard]]
std::tuple<Node, bool, uint32_t> compareNode(
    uint32_t Offset,
    StringRef Name,
    bool Strict,
    char PreviousCharInName,
    BufferType& Buffer,
    const Node* Parent = nullptr
)
{
    Node N = readNode(Offset, Parent);
    std::size_t Consummed = 0;
    bool DoesStartWith
        = N.IsRoot || startsWith(Name, N.Name, Strict, Consummed, PreviousCharInName);
    if (!DoesStartWith) {
        return std::make_tuple(N, false, 0);
    }

    if (Name.size() - Consummed == 0 && N.Value != 0xFFFFFFFF) {
        return std::make_tuple(N, true, N.Value);
    }

    if (N.hasChildren()) {
        uint32_t ChildOffset = N.ChildrenOffset;
        for (;;) {
            Node C;
            bool Matches;
            uint32_t Value;
            std::tie(C, Matches, Value) = compareNode(
                ChildOffset, Name.substr(Consummed), Strict, PreviousCharInName, Buffer, &N
            );
            if (Matches) {
                std::reverse_copy(C.Name.begin(), C.Name.end(), std::back_inserter(Buffer));
                return std::make_tuple(N, true, Value);
            }
            ChildOffset += C.Size;
            if (!C.HasSibling) {
                break;
            }
        }
    }
    return std::make_tuple(N, false, 0);
}

[[nodiscard]]
std::tuple<Node, bool, uint32_t>
compareNode(uint32_t Offset, StringRef Name, bool Strict, BufferType& Buffer)
{
    return compareNode(Offset, Name, Strict, 0, Buffer);
}

// clang-format off
constexpr const char *const HangulSyllables[][3] = {
    { "G",  "A",   ""   },
    { "GG", "AE",  "G"  },
    { "N",  "YA",  "GG" },
    { "D",  "YAE", "GS" },
    { "DD", "EO",  "N", },
    { "R",  "E",   "NJ" },
    { "M",  "YEO", "NH" },
    { "B",  "YE",  "D"  },
    { "BB", "O",   "L"  },
    { "S",  "WA",  "LG" },
    { "SS", "WAE", "LM" },
    { "",   "OE",  "LB" },
    { "J",  "YO",  "LS" },
    { "JJ", "U",   "LT" },
    { "C",  "WEO", "LP" },
    { "K",  "WE",  "LH" },
    { "T",  "WI",  "M"  },
    { "P",  "YU",  "B"  },
    { "H",  "EU",  "BS" },
    { 0,    "YI",  "S"  },
    { 0,    "I",   "SS" },
    { 0,    0,     "NG" },
    { 0,    0,     "J"  },
    { 0,    0,     "C"  },
    { 0,    0,     "K"  },
    { 0,    0,     "T"  },
    { 0,    0,     "P"  },
    { 0,    0,     "H"  }
    };
// clang-format on

// Unicode 15.0
// 3.12 Conjoining Jamo Behavior Common constants
constexpr char32_t SBase = 0xAC00;
constexpr uint32_t LCount = 19;
constexpr uint32_t VCount = 21;
constexpr uint32_t TCount = 28;

[[nodiscard]]
std::size_t findSyllable(StringRef Name, bool Strict, char& PreviousInName, int& Pos, int Column)
{
    COWEL_ASSERT(Column == 0 || Column == 1 || Column == 2);
    static std::size_t CountPerColumn[] = { LCount, VCount, TCount };
    int Len = -1;
    int Prev = PreviousInName; // NOLINT
    for (std::size_t I = 0; I < CountPerColumn[Column]; I++) {
        StringRef Syllable(HangulSyllables[I][Column]);
        if (int(Syllable.size()) <= Len) {
            continue;
        }
        std::size_t Consummed = 0;
        char PreviousInNameCopy = PreviousInName;
        bool DoesStartWith = startsWith(Name, Syllable, Strict, Consummed, PreviousInNameCopy);
        if (!DoesStartWith) {
            continue;
        }
        Len = int(Consummed);
        Pos = int(I);
        Prev = PreviousInNameCopy; // NOLINT
    }
    if (Len == -1) {
        return 0;
    }
    PreviousInName = char(Prev);
    return size_t(Len);
}

[[nodiscard]]
std::optional<char32_t> nameToHangulCodePoint(StringRef Name, bool Strict, BufferType& Buffer)
{
    Buffer.clear();
    // Hangul Syllable Decomposition
    std::size_t Consummed = 0;
    char NameStart = 0;
    bool DoesStartWith = startsWith(Name, "HANGUL SYLLABLE ", Strict, Consummed, NameStart);
    if (!DoesStartWith) {
        return std::nullopt;
    }
    Name = Name.substr(Consummed);
    int L = -1;
    int V = -1;
    int T = -1;
    Name = Name.substr(findSyllable(Name, Strict, NameStart, L, 0));
    Name = Name.substr(findSyllable(Name, Strict, NameStart, V, 1));
    Name = Name.substr(findSyllable(Name, Strict, NameStart, T, 2));
    if (L != -1 && V != -1 && T != -1 && Name.empty()) {
        if (!Strict) {
            Buffer.append("HANGUL SYLLABLE ");
            if (L != -1) {
                Buffer.append(HangulSyllables[L][0]);
            }
            if (V != -1) {
                Buffer.append(HangulSyllables[V][1]);
            }
            if (T != -1) {
                Buffer.append(HangulSyllables[T][2]);
            }
        }
        return SBase + ((std::uint32_t(L) * VCount + std::uint32_t(V)) * TCount) + std::uint32_t(T);
    }
    // Otherwise, it's an illegal syllable name.
    return std::nullopt;
}

struct GeneratedNamesData {
    StringRef Prefix;
    uint32_t Start;
    uint32_t End;
};

// Unicode 15.1 Table 4-8. Name Derivation Rule Prefix Strings
constexpr GeneratedNamesData GeneratedNamesDataTable[] = {
    { "CJK UNIFIED IDEOGRAPH-", 0x3400, 0x4DBF },
    { "CJK UNIFIED IDEOGRAPH-", 0x4E00, 0x9FFF },
    { "CJK UNIFIED IDEOGRAPH-", 0x20000, 0x2A6DF },
    { "CJK UNIFIED IDEOGRAPH-", 0x2A700, 0x2B739 },
    { "CJK UNIFIED IDEOGRAPH-", 0x2B740, 0x2B81D },
    { "CJK UNIFIED IDEOGRAPH-", 0x2B820, 0x2CEA1 },
    { "CJK UNIFIED IDEOGRAPH-", 0x2CEB0, 0x2EBE0 },
    { "CJK UNIFIED IDEOGRAPH-", 0x2EBF0, 0x2EE5D },
    { "CJK UNIFIED IDEOGRAPH-", 0x30000, 0x3134A },
    { "CJK UNIFIED IDEOGRAPH-", 0x31350, 0x323AF },
    { "TANGUT IDEOGRAPH-", 0x17000, 0x187F7 },
    { "TANGUT IDEOGRAPH-", 0x18D00, 0x18D08 },
    { "KHITAN SMALL SCRIPT CHARACTER-", 0x18B00, 0x18CD5 },
    { "NUSHU CHARACTER-", 0x1B170, 0x1B2FB },
    { "CJK COMPATIBILITY IDEOGRAPH-", 0xF900, 0xFA6D },
    { "CJK COMPATIBILITY IDEOGRAPH-", 0xFA70, 0xFAD9 },
    { "CJK COMPATIBILITY IDEOGRAPH-", 0x2F800, 0x2FA1D },
};

[[nodiscard]]
std::optional<char32_t> nameToGeneratedCodePoint(StringRef Name, bool Strict, BufferType& Buffer)
{
    for (auto&& Item : GeneratedNamesDataTable) {
        Buffer.clear();
        std::size_t Consummed = 0;
        char NameStart = 0;
        bool DoesStartWith
            = startsWith(Name, Item.Prefix, Strict, Consummed, NameStart, /*IsPrefix=*/true);
        if (!DoesStartWith) {
            continue;
        }
        auto Number = Name.substr(Consummed);
        unsigned long long V = 0;
        // Be consistent about mandating upper casing.
        if (Strict && std::ranges::any_of(Number, [](char C) { return C >= 'a' && C <= 'f'; })) {
            return {};
        }
        if (getAsUnsignedInteger(Number, 16, V) || V < Item.Start || V > Item.End) {
            continue;
        }
        if (!Strict) {
            Buffer.append(Item.Prefix);
            Buffer.append(utohexstr(V, /* LowerCase=*/true));
        }
        return V;
    }
    return std::nullopt;
}

[[nodiscard]]
std::optional<char32_t> nameToCodepoint(StringRef Name, bool Strict, BufferType& Buffer)
{
    if (Name.empty()) {
        return std::nullopt;
    }

    std::optional<char32_t> Res = nameToHangulCodePoint(Name, Strict, Buffer);
    if (!Res) {
        Res = nameToGeneratedCodePoint(Name, Strict, Buffer);
    }
    if (Res) {
        return Res;
    }

    Buffer.clear();
    Node Node;
    bool Matches;
    uint32_t Value;
    std::tie(Node, Matches, Value) = compareNode(0, Name, Strict, Buffer);
    if (Matches) {
        std::ranges::reverse(Buffer);
        // UAX44-LM2. Ignore case, whitespace, underscore ('_'), and all medial
        // hyphens except the hyphen in U+1180 HANGUL JUNGSEONG O-E.
        if (!Strict && Value == 0x116c && contains_insensitive(Name, "O-E")) {
            Buffer = "HANGUL JUNGSEONG O-E";
            Value = 0x1180;
        }
        return Value;
    }
    return std::nullopt;
}

} // namespace

struct LooseMatchingResult {
    char32_t CodePoint;
    std::string Name;
};

struct MatchForCodepointName {
    std::string Name;
    uint32_t Distance = 0;
    char32_t Value = 0;
};

namespace {

[[nodiscard]] [[maybe_unused]]
std::optional<char32_t> nameToCodepointStrict(StringRef Name)
{

    BufferType Buffer;
    auto Opt = nameToCodepoint(Name, /* Strict=*/true, Buffer);
    return Opt;
}

[[nodiscard]] [[maybe_unused]]
std::optional<LooseMatchingResult> nameToCodepointLooseMatching(StringRef Name)
{
    BufferType Buffer;
    auto Opt = nameToCodepoint(Name, /* Strict=*/false, Buffer);
    if (!Opt) {
        return std::nullopt;
    }
    return LooseMatchingResult { *Opt, Buffer };
}

// Find the unicode character whose editing distance to Pattern
// is shortest, using the Wagnerâ€“Fischer algorithm.
[[nodiscard]] [[maybe_unused]]
std::vector<MatchForCodepointName>
nearestMatchesForCodepointName(StringRef Pattern, std::size_t MaxMatchesCount)
{
    // We maintain a fixed size vector of matches,
    // sorted by distance
    // The worst match (with the biggest distance) are discarded when new elements
    // are added.
    std::size_t LargestEditDistance = 0;
    std::vector<MatchForCodepointName> Matches;
    Matches.reserve(MaxMatchesCount + 1);

    auto Insert = [&](const Node& Node, uint32_t Distance, char32_t Value) -> bool {
        if (Distance > LargestEditDistance) {
            if (Matches.size() == MaxMatchesCount) {
                return false;
            }
            LargestEditDistance = Distance;
        }
        // To avoid allocations, the creation of the name is delayed
        // as much as possible.
        std::string Name;
        auto GetName = [&] {
            if (Name.empty()) {
                Name = Node.fullName();
            }
            return Name;
        };

        auto It = std::lower_bound( // NOLINT(modernize-use-ranges)
            Matches.begin(), Matches.end(), Distance,
            [&](const MatchForCodepointName& a, std::size_t Distance) {
                if (Distance == a.Distance) {
                    return a.Name < GetName();
                }
                return a.Distance < Distance;
            }
        );
        if (It == Matches.end() && Matches.size() == MaxMatchesCount) {
            return false;
        }

        MatchForCodepointName M { GetName(), Distance, Value };
        Matches.insert(It, std::move(M));
        if (Matches.size() > MaxMatchesCount) {
            Matches.pop_back();
        }
        return true;
    };

    // We ignore case, space, hyphens, etc,
    // in both the search pattern and the prospective names.
    auto Normalize = [](StringRef Name) {
        std::string Out;
        Out.reserve(Name.size());
        for (char C : Name) {
            if (isAlnum(C)) {
                Out.push_back(toUpper(C));
            }
        }
        return Out;
    };
    std::string NormalizedName = Normalize(Pattern);

    // Allocate a matrix big enough for longest names.
    const std::size_t Columns
        = std::min(NormalizedName.size(), UnicodeNameToCodepointLargestNameSize) + 1;

    [[maybe_unused]]
    static std::size_t Rows
        = UnicodeNameToCodepointLargestNameSize + 1;

    std::vector<char> Distances(Columns * (UnicodeNameToCodepointLargestNameSize + 1), 0);

    auto Get = [&Distances, Columns](size_t Column, std::size_t Row) -> char& {
        COWEL_ASSERT(Column < Columns);
        COWEL_ASSERT(Row < Rows);
        return Distances[(Row * Columns) + Column];
    };

    for (std::size_t I = 0; I < Columns; I++) {
        Get(I, 0) = char(I);
    }

    // Visit the childrens,
    // Filling (and overriding) the matrix for the name fragment of each node
    // iteratively. CompleteName is used to collect the actual name of potential
    // match, respecting case and spacing.
    const auto VisitNode = [&](const Node& N, std::size_t Row, auto& VisitNode) -> void {
        std::size_t J = 0;
        for (; J < N.Name.size(); J++) {
            if (!isAlnum(N.Name[J])) {
                continue;
            }

            Get(0, Row) = char(Row);

            for (std::size_t I = 1; I < Columns; I++) {
                const int Delete = Get(I - 1, Row) + 1;
                const int Insert = Get(I, Row - 1) + 1;

                const int Replace
                    = Get(I - 1, Row - 1) + (NormalizedName[I - 1] != N.Name[J] ? 1 : 0);

                Get(I, Row) = char(std::min({ Insert, Delete, Replace }));
            }

            Row++;
        }

        auto Cost = unsigned(Get(Columns - 1, Row - 1)); // NOLINT
        if (N.Value != 0xFFFFFFFF) {
            Insert(N, Cost, N.Value);
        }

        if (N.hasChildren()) {
            auto ChildOffset = N.ChildrenOffset;
            for (;;) {
                Node C = readNode(ChildOffset, &N);
                ChildOffset += C.Size;
                if (!C.isValid()) {
                    break;
                }
                VisitNode(C, Row, VisitNode);
                if (!C.HasSibling) {
                    break;
                }
            }
        }
    };

    Node Root = createRoot();
    VisitNode(Root, 1, VisitNode);
    return Matches;
}

} // namespace

char32_t code_point_by_name(std::u8string_view name) noexcept
{
    const std::optional<char32_t> result = nameToCodepointStrict(as_string_view(name));
    return result ? *result : char32_t(-1);
}

} // namespace cowel
