\h2{Syntax}

COWEL has a minimalistic but powerful syntax,
built on top of only three syntactical constructs:
\ul{
  \li{\cowdoc_c{Text.}}
  \li{Escape sequences, such as \cowdoc_c{\\\U{7B}}, \cowdoc_c{\\\U{7D}}, \cowdoc_c{\\\\}, etc.}
  \li{\cowdoc_c{\\:Comments}}
  \li{\cowdoc_c{\\various_directives(positional args, named-args = 0){and content}}}
}

\h3{EBNF grammar}

Formally, in \ref(https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form){EBNF}
grammar format,
a \gterm{document} is constructed as follows:

\: FIXME: includes are meant to be relative to the current document,
\: so specifying "intro/" as the base path should not be necessary.
\codeblock(ebnf){\cowel_include_text{grammar.ebnf}}

\Bnote{
At the top-level in the \gterm{document},
there are no other syntactical features,
meaning that as long as some bit of code doesn't contain a \cowdoc_cp{005C},
it's all interpreted as plaintext.
This makes COWEL exceptionally suited to nest other languages inside of it in code blocks etc.
}

\h3{Text}

\dfn{Text} (\gterm{text} in the grammar) is a \gterm{markup-element}
which consists of as many characters as possible,
excluding \cowdoc_cp{005C}.

\codeblock(ebnf){
text
  = ? Maximal character sequence excluding "\\" ?;
}

\Bnote{
In most situations, text is not processed specially.
However, the output may depend on the context (\ref(#contexts-and-output)).
For example, \cowdoc_c{<} in text will render as a < character,
but will be converted to \cowdoc_html{&lt;} when fed into a To-HTML Policy.
Furthermore, text is subject to special effects like syntax highlighting
and paragraph splitting.
}

\h4{Whitespace}

COWEL translates text in whitespace directly into HTML in most situations.
Additional styling with CSS can be applied
to interpret that whitespace literally (like in \cowdoc_html{<pre>} elements)
or to have it merged into spaces,
which happens by default.

At the document top-level,
\ref(#paragraph-splitting) takes place.

\Bex{
COWEL markup:
\cowblock{
This displays on one line
because line breaks render like spaces.
}
Generated HTML:
\htmlblock{
<p>This displays on one line
because line breaks render like spaces.</p>
}
Rendered output:
\Bindent{This displays on one line because line breaks render like spaces.}
}

\h3{Escape sequences}

COWEL supports multiple escape sequences,
all of which begin with a \cowdoc_c{\\} (like directives),
but are followed by some special character.
The meaning of the escape sequences is described in the table below.

\style{
  #escapes-table {
    margin-left:auto;
    margin-right:auto;
    table-layout: fixed;
  }
  #escapes-table td {
    border-top: 1px solid var(--border-color);
  }
  #escapes-table td:first-child {
    width: 40%;
  }
}

\table(id=escapes-table){
  \tr{
    \th{Escape sequence}
    \th{Meaning}
  }
  \tr{
    \td{
      \cowdoc_esc{\N{LEFT CURLY BRACKET}},
      \cowdoc_esc{\N{RIGHT CURLY BRACKET}},
      \cowdoc_esc{\\},
      \cowdoc_esc{\N{LEFT PARENTHESIS}},
      \cowdoc_esc{\N{RIGHT PARENTHESIS}},
      \cowdoc_esc{,},
      \cowdoc_esc{.},
      \cowdoc_esc{=}
    }
    \td{
      Expands to the second character in the escape sequence.
      These sequences are stable.
    }
  }
  \tr{
    \td{
      \cowdoc_esc{!},
      \cowdoc_esc{"},
      \cowdoc_esc{#},
      \cowdoc_esc{\N{DOLLAR SIGN}},
      \cowdoc_esc{\N{PERCENT SIGN}},
      \cowdoc_esc{&},
      \cowdoc_esc{'},
      \cowdoc_esc{*},
      \cowdoc_esc{+},
      \cowdoc_esc{-},
      \cowdoc_esc{/},
      \cowdoc_esc{;},
      \cowdoc_esc{<},
      \cowdoc_esc{>},
      \cowdoc_esc{?},
      \cowdoc_esc{@},
      \cowdoc_esc{\N{LEFT SQUARE BRACKET}},
      \cowdoc_esc{\N{RIGHT SQUARE BRACKET}},
      \cowdoc_esc{^},
      \cowdoc_esc{|},
      \cowdoc_esc{~},
      \nobr{\cowdoc_esc U+0009 CHARACTER TABULATION},
      \nobr{\cowdoc_esc U+0020 SPACE}
    }
    \td{
      Expands to the second character in the escape sequence.
      \strong{These sequences are unstable},
      meaning that they could be given a different meaning in the future.
      \strong{Use with caution!}
    }
  }
  \tr{
    \td{
      \nobr{\cowdoc_esc U+000A LINE FEED},
      \nobr{\cowdoc_esc U+000B VERTICAL TABULATION},
      \nobr{\cowdoc_esc U+000D CARRIAGE RETURN},
      \nobr{\cowdoc_esc U+000A U+000D (CRLF escape)}
    }
    \td{
      Expands to nothing; feature is stable
    }
  }
}

In EBNF grammar, an \gterm{escape} is constructed like:

\codeblock(ebnf){
escape
  = "\", escapable
  | "\", line-terminator;
escapable
  =  "{" |  "}" |  "[" |  "]" |  "(" |  ")" |  "," |  "." |  "=" |  "!"
  |  '"' |  "#" |  "\N{DOLLAR SIGN}" |  "%" |  "&" |  "'" |  "*" |  "+" |  "/" |  ";"
  |  "<" |  ">" |  "?" |  "@" |  "^" |  "|" |  "~" |  "-"
  |  " " |  TAB |   VT ;
line-terminator
  = LF | CR, LF | CR
  (* Ambiguities are resolved in favor of a single CRLF line-terminator,
     instead of two CR and LF line-terminators *);
}

If there is an ambiguity between a CRLF escape and a simple U+000D CARRIAGE RETURN escape,
this ambiguity is resolved in favor of a CRLF escape.

\Bnote{
The purpose of most escapes is to prevent a character from having special meaning.
For example, the \cowdoc_esc{,} escape prevents a comma from being interpreted
as a separator between directive arguments.

The purpose of the newline escapes is to remove unwanted newlines
and to join long content that spans multiple lines,
but without introducing any whitespace in the markup.
}

\h3(id=syntax-comments){Comments}

Comments begin with \cowdoc_c{\\:} and extend until the end of the line.
In almost every context,
comments are discarded instead of being emitted into the output HTML.

This makes them useful for adding information to the COWEL markup.

\Bnote{
Comments, just like any other content,
are actually part of the AST and don't simply get discarded during parsing.
This means that a comment wrapped in \ref(#dir-cowel_source_as_text) will render as expected:
\cowblock{\cowel_source_as_text{
\cowblock{\cowel_source_as_text{
\: A comment ...
}}
}}
This renders as:
\cowblock{\cowel_source_as_text{
\: A comment ...
}}
}

In EBNF grammar, a \gterm{comment} is constructed as follows:

\codeblock(ebnf){
comment
  = "\\:", ? Maximal character sequence up to and including line-terminator ?;
}

Comments include a \gterm{line-terminator},
which means that a trailing comment won't add any lines (not even blank lines)
to the generated markup.

\Bex{
We can even join words by putting a comment between:
\cowblock{\literally{
Hello\: this comment will absorb the newline
World

Hello \: this comment also does, but is preceded by a space
World
}}

Generated HTML:
\htmlblock{
HelloWorld

Hello World
}
}

\h3{Directives}

A \dfn{directive} is a way of generating plaintext, HTML, both, or neither.
You can think of it as a "command" or "function call".

Every directive has three parts:
\ul{
  \li{
    The \cowdoc_c{\\directive_name} selects a specific directive to be processed.
  }
  \li{
    An optional \cowdoc_c{\cowel_highlight_phantom{\\d}\
(comma-separated, positional arguments, named-arguments = ...)}
    provides additional inputs to the directive.
  }
  \li{
    An optional \cowdoc_c{\cowel_highlight_phantom{\\d}{block of content}}
    provides a "main input" to a directive.
  }
}

In EBNF grammar, a \gterm{directive} is constructed as follows:

\codeblock(ebnf){
directive
  = "\", directive-name, [ group ], [ "{", { markup-element }, "}" ];
directive-name
  = directive-name-character - digit, { directive-name-character };
directive-name-character
  = "_" | digit | ? ASCII alphabetic character ?;
}

\h4{Directive names}

A \dfn{directive name} selects a specific directive to be processed.
The name begins with a \cowdoc_cp{005C} character,
followed by a sequence of ASCII alphanumeric characters or \cowdoc_cp{005F}.
However, the first character after \cowdoc_cp{005C} cannot be an ASCII digit.

\Btip{
You can use an empty block of content to "cut a name short":
\cowblock{
Thisisavery\\wbr{}longword.
}
Doing so is equivalent to writing
\cowdoc_c{\\wbr} and \cowdoc_c{longword} immediately following one another.
}

Grammatically, the arguments are a \gterm{group},
which is constructed as follows:

\codeblock(ebnf){
group
  = "(", group-member-list, whitespace, ")";
group-member-list
  = member-comments, group-member,
    { whitespace, ",", member-comments, group-member },
    whitespace, [ "," ];
group-member
  = member-name, whitespace, "=", whitespace, member-value
  | member-value
  | "...";
}

\h4{Directive arguments}

\dfn{Directive arguments} can be
\dfn{positional arguments},
\dfn{named arguments}, or
\dfn{ellipses}.
Arguments are separated by commas.
Unlike anywhere else, whitespace surrounding directive arguments is ignored.
The value of positional or named argument is either a \dfn{markup sequence} or a \dfn{group}.

\Bex{
Often, arguments are converted to HTML attributes.
\cowblock{
\\b(id = abc){Bold text.}
}
Generated HTML:
\htmlblock{
<b id=abc>Bold text.</b>
}
}

\h5{Named arguments}

Named arguments are of the form
\cowdoc_c{name = value}, where spaces anywhere around \cowdoc_c{name} and \cowdoc_c{value} are ignored.
Named arguments are matched to directive parameters before any positional arguments,
meaning that positional arguments fill the remaining unmatched arguments.

Argument names can consist of any character, except
ASCII control characters,
U+0020\c{nbsp}SPACE,
\cowdoc_cp{0022},
\cowdoc_cp{0027},
\cowdoc_cp{002C},
\cowdoc_cp{002F},
\cowdoc_cp{003D},
\cowdoc_cp{003E},
\cowdoc_cp{005B},
\cowdoc_cp{005C},
\cowdoc_cp{005D},
\cowdoc_cp{007B},
\cowdoc_cp{007D},
and noncharacters.

\Btip{
If you want to provide a positional argument that is \cowdoc_c{name = value} instead,
you can do so by writing:
\cowblock{\literally{
\: "name = value" as a positional argument
\xyz(name \\= value)
\: named argument with name "name" and value "value"
\xyz(name = value)
}}
Only the literal \cowdoc_c{=} character can be used for named arguments,
not its escaped variant \cowdoc_c{\\=}.
}

Grammatically, a \gterm{member-name} is constructed as follows:

\codeblock(ebnf){
member-name
  = ? HTML attribute name ? - ("\\" | "(" | ")" | "{", "}" | ",");
}

\h5{Positional arguments}

Positional arguments are content just like any other content,
except that an unbalanced closing \cowdoc_cp{005D} or a \cowdoc_cp{002C}
ends the content.

\Btip{
You can use escape sequences to continue otherwise ended content.
\cowblock{\literally{
\xyz(hello, world)   \: Two positional arguments
\xyz(hello\, world)  \: One positional argument containing a comma.
\xyz(hello()world)   \: OK, () is balanced and included in single argument
\xyz(hello\)world)   \: OK
\xyz(hello\(world)   \: OK
\xyz(hello(world)    \: error: unterminated arguments
}}
}

Grammatically, a positional argument is a \gterm{member-value},
constructed as follows:

\codeblock(ebnf){
member-value
  = { member-value-markup-element }
  | group;
member-value-markup-element
  = member-value-text
  | escape
  | comment
  | directive;
member-value-text
  = ? Maximal character sequence excluding "\\", ",", or balanced ")" ?;
member-comments
  = { comment | whitespace };
}

\h5{Ellipses}

Ellipsis arguments (spelled \ellipsis)
are placeholders which expand to arguments provided to a surrounding macro.
See also \ref(#dir-cowel_macro) and \ref(#dir-cowel_put).

\Bex{
COWEL markup:
\cowblock{\literally{
\: Define a macro for generating <div> elements
\cowel_macro(div){\cowel_html_element(div, ...){\cowel_put}}

\div(id = abc){inner text}
}}
Generated HTML:
\htmlblock{
<div id=abc>inner text</div>
}
}

Specifically, any positional argument which begins with \ellipsis
(ignoring leading whitespace and comments)
is considered an ellipsis.
The text \tt{...} is not considered an ellipsis if it appears anywhere else
or has preceding content within an argument.

An error is raised if
\ul{
  \li{
    any content follows the ellipsis, or
  }
  \li{
    an ellipsis is used as an argument outside of a macro expansion.
  }
}

\Btip{
To literally provide the text \tt{...} as an argument,
you can use the escape sequence \cowdoc_c{\\...} (only the first dot is part of the escape).
}

\Bex{
\: We cannot use \literally here because it would cause a parse error
\cowblock{
\\cowel_macro(m){\\x(...)}        \\: OK, all macro arguments are forwarded to \\x
\\cowel_macro(e){\\x(...text)}    \\: error: content following an ellipsis

\\m(...)                         \\: error: ellipsis is not expanded from a macro
\\m(\\...)                        \\: OK
\\m(\\.\\.\\.)                      \\: OK
}
}

\h5{Groups}

Groups make it possible to group any of the aforementioned constructs.
Groups begin with \code(cowel){\cowel_highlight_phantom{\\d}\N{LEFT PARENTHESIS}}
and end with \code(cowel){\cowel_highlight_phantom{\\d\N{LEFT PARENTHESIS}}\N{RIGHT PARENTHESIS}}.
They can appear both in positional and in named arguments.

\Bex{
\codeblock(cowel){\literally{
\d((x), ())    \: groups as positional arguments
\d(n = (x, y)) \: group as named argument
\d(((())))     \: nested empty groups
}}
}

\h4{Directive content}

The \dfn{directive content} is the primary input to a directive.
It is delimited by a '\tt{\{}' and ends with a \em{matching} closing '\tt{\}}'.
This means that you can have opening and closing braces inside text,
but they need to be balanced.

\Bex{
COWEL markup:
\cowblock{
\\b{Bold text { with braces }.}
}
Generated HTML:
\htmlblock{
<b>Bold text { with braces }.</b>
}
}

Escape sequences don't participate in this "brace matching",
so they can be used to literally produce a brace character.
\Bex{
COWEL markup:
\cowblock{
\\b{Bold text \\\U{7B} with brace.}
}
Generated HTML:
\htmlblock{
<b>Bold text \U{7B} with brace.</b>
}
}

Unlike in the directive arguments,
whitespace is not trimmed.
\Bex{
COWEL markup:
\cowblock{
\\b{bold} \\i{ italic }
}
Generated HTML:
\htmlblock{
<b>bold</b> <i> italic </i>
}
}

\Bnote{
Only one such block of content can be provided, unlike in TeX,
which has a similar syntax,
but permits multiple blocks. Each block is separated by a pair of braces.
}
