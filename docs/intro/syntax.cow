\h2{Syntax}

COWEL has a minimalistic but powerful syntax,
built on top of only three syntactical constructs:
\ul{
  \li{\cowdoc_c{Text.}}
  \li{Escape sequences, such as \cowdoc_c{\\\U(0x7B)}, \cowdoc_c{\\\U(0x7D)}, \cowdoc_c{\\\\}, etc.}
  \li{\cowdoc_c{\\:Comments}}
  \li{\cowdoc_c{\\directive_splices(positional, args, named-args = 0){and content}}}
}

\h3{EBNF grammar}

Formally, in \ref("https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"){EBNF}
grammar format,
a \gterm{document} is constructed as follows:

\codeblock(ebnf){\cowel_include_text("grammar.ebnf")}

\Bnote{
At the top-level in the \gterm{document},
there are no other syntactical features,
meaning that as long as some bit of code doesn't contain a \cowdoc_cp(0x5C),
it's all interpreted as plaintext.
This makes COWEL exceptionally suited to nest other languages inside of it in code blocks etc.
}

\h3{Text}

\dfn{Text} (such as \gterm{document-text} in the grammar)
is a markup element which consists of as many characters as possible,
excluding \cowdoc_cp(0x5C).

\codeblock(ebnf){
document-text
  = document-text-char, { document-text-char };
document-text-char
  = ? Any character ? - "\\";
}

\Bnote{
In most situations, text is not processed specially.
However, the output may depend on the context (\ref("#contexts-and-output")).
For example, \cowdoc_c{<} in text will render as a < character,
but will be converted to \cowdoc_html{&lt;} when fed into a To-HTML Policy.
Furthermore, text is subject to special effects like syntax highlighting
and paragraph splitting.
}

\h4{Whitespace}

COWEL translates text in whitespace directly into HTML in most situations.
Additional styling with CSS can be applied
to interpret that whitespace literally (like in \cowdoc_html{<pre>} elements)
or to have it merged into spaces,
which happens by default.

At the document top-level,
\ref("#paragraph-splitting") takes place.

\Bex{
COWEL markup:
\cowblock{
This displays on one line
because line breaks render like spaces.
}
Generated HTML:
\htmlblock{
<p>This displays on one line
because line breaks render like spaces.</p>
}
Rendered output:
\Bindent{This displays on one line because line breaks render like spaces.}
}

\h3{Escape sequences}

COWEL supports multiple escape sequences,
all of which begin with a \cowdoc_c{\\} (like directives),
but are followed by some special character.
The meaning of the escape sequences is described in the table below.

\style{
  #escapes-table {
    margin-left:auto;
    margin-right:auto;
    table-layout: fixed;
  }
  #escapes-table td {
    border-top: 1px solid var(--border-color);
  }
  #escapes-table td:first-child {
    width: 40%;
  }
}

\table(id=escapes-table){
  \tr{
    \th{Escape sequence}
    \th{Meaning}
  }
  \tr{
    \td{
      \cowdoc_esc{\N{LEFT CURLY BRACKET}},
      \cowdoc_esc{\N{RIGHT CURLY BRACKET}},
      \cowdoc_esc{\\},
      \cowdoc_esc{"},
    }
    \td{
      Expands to the second character in the escape sequence.
      These sequences are stable.
    }
  }
  \tr{
    \td{
      \cowdoc_esc{!},
      \cowdoc_esc{#},
      \cowdoc_esc{\N{DOLLAR SIGN}},
      \cowdoc_esc{\N{PERCENT SIGN}},
      \cowdoc_esc{&},
      \cowdoc_esc{'},
      \cowdoc_esc{\N{LEFT PARENTHESIS}},
      \cowdoc_esc{\N{RIGHT PARENTHESIS}},
      \cowdoc_esc{*},
      \cowdoc_esc{+},
      \cowdoc_esc{,},
      \cowdoc_esc{-},
      \cowdoc_esc{.},
      \cowdoc_esc{/},
      \cowdoc_esc{;},
      \cowdoc_esc{<},
      \cowdoc_esc{=}
      \cowdoc_esc{>},
      \cowdoc_esc{?},
      \cowdoc_esc{@},
      \cowdoc_esc{\N{LEFT SQUARE BRACKET}},
      \cowdoc_esc{\N{RIGHT SQUARE BRACKET}},
      \cowdoc_esc{^},
      \cowdoc_esc{|},
      \cowdoc_esc{~},
      \nobr{\cowdoc_esc U+0009 CHARACTER TABULATION},
      \nobr{\cowdoc_esc U+0020 SPACE}
    }
    \td{
      Expands to the second character in the escape sequence.
      \strong{These sequences are unstable},
      meaning that they could be given a different meaning in the future.
      \strong{Use with caution!}
    }
  }
  \tr{
    \td{
      \nobr{\cowdoc_esc U+000A LINE FEED},
      \nobr{\cowdoc_esc U+000B VERTICAL TABULATION},
      \nobr{\cowdoc_esc U+000D CARRIAGE RETURN},
      \nobr{\cowdoc_esc U+000A U+000D (CRLF escape)}
    }
    \td{
      Expands to nothing; feature is stable
    }
  }
}

In EBNF grammar, an \gterm{escape} is constructed like:

\codeblock(ebnf){
escape
  = "\\", escapable-char
  | "\\", line-terminator;
escapable-char
  =  "{" |  "}" |  "[" |  "]" |  "(" |  ")" |  "," |  "." |  "=" |  "!"
  |  '"' |  "#" |  "\N{DOLLAR SIGN}" |  "%" |  "&" |  "'" |  "*" |  "+" |  "/" |  ";"
  |  "<" |  ">" |  "?" |  "@" |  "^" |  "|" |  "~" |  "-"
  |  " " |  TAB |   VT ;
line-terminator
  = LF
  | CR, LF
  | CR (* unless the next character is LF *);
}

If there is an ambiguity between a CRLF escape and a simple U+000D CARRIAGE RETURN escape,
this ambiguity is resolved in favor of a CRLF escape.

\Bnote{
The purpose of most escapes is to prevent a character from having special meaning.
For example, the \cowdoc_esc{,} escape prevents a comma from being interpreted
as a separator between directive arguments.

The purpose of the newline escapes is to remove unwanted newlines
and to join long content that spans multiple lines,
but without introducing any whitespace in the markup.
}

\h3(id=syntax-comments){Comments}

Comments begin with \cowdoc_c{\\:} and extend until the end of the line.
In almost every context,
comments are discarded instead of being emitted into the output HTML.

This makes them useful for adding information to the COWEL markup.

\Bnote{
Comments, just like any other content,
are actually part of the AST and don't simply get discarded during parsing.
This means that a comment wrapped in \ref("#dir-cowel_source_as_text") will render as expected:
\cowblock{\cowel_source_as_text{
\cowblock{\cowel_source_as_text{
\: A comment ...
}}
}}
This renders as:
\cowblock{\cowel_source_as_text{
\: A comment ...
}}
}

In EBNF grammar, a \gterm{comment} is constructed as follows:

\codeblock(ebnf){
comment
  = "\\:", { comment-char }, line-terminator;
comment-char
  = ? Any character ? - line-terminator;
}

Comments include a \gterm{line-terminator},
which means that a trailing comment won't add any lines (not even blank lines)
to the generated markup.

\Bex{
We can even join words by putting a comment between:
\cowblock{\literally{
Hello\: this comment will absorb the newline
World

Hello \: this comment also does, but is preceded by a space
World
}}

Generated HTML:
\htmlblock{
HelloWorld

Hello World
}
}

\h3{Directives splices}

A \dfn{directive} is a way of generating plaintext, HTML, both, or neither.
You can think of it as a "command" or "function call".

\dfn{Splicing} means to evaluate a directive (or something else, in the future)
and to insert the result between the surrounding markup elements.
Splicing consists of three steps:

\ol{
  \li{
    Looking up the name of the spliced directive.
  }
  \li{
    Evaluating the directive (and its arguments, if any).
    Evaluation of the directive usually produces a result.
    This may not happen when evaluation raises an error.
  }
  \li{
    Feeding the result into the current content policy (\ref("#contexts-and-output")).
  }
}

\Bex{
COWEL markup:
\cowblock{\literally{
1 + 2 + 3 = \cowel_add(1, 2, 3)
}}
Generated HTML:
\htmlblock{
1 + 2 + 3 = \cowel_add(1, 2, 3)
}
As explained, this markup is processed in three steps:
\ol{
  \li{
    \cowdoc_dir{cowel_add} is looked up by name.
    This succeeds because \cowdoc_dir{cowel_add} is a builtin directive.
  }
  \li{
    The three arguments (of type \cowdoc_type{int}) to \cowdoc_dir{cowel_add}
    are evaluated,
    and \cowdoc_dir{cowel_add} itself is evaluated,
    which produces a value \cowdoc_c{6} of type \cowdoc_type{int}.
  }
  \li{
    The resulting value \cowdoc_c{6} is fed as plaintext
    into the surrounding content policy,
    which usually results in a single \cowdoc_cp(0x36) character being output.
  }
}
}

Every directive has three parts:
\ul{
  \li{
    The \cowdoc_c{\\directive_name} selects a specific directive to be processed.
  }
  \li{
    An optional \cowdoc_c{\cowel_highlight_phantom{\\d}\
(comma-separated, positional, arguments, named-arguments = ...)}
    group provides additional inputs to the directive.
  }
  \li{
    An optional \cowdoc_c{\cowel_highlight_phantom{\\d}{block of content}}
    provides a "main input" to a directive.
  }
}

In EBNF grammar, a \gterm{directive-splice} is constructed as follows:

\codeblock(ebnf){
directive-splice
  = "\\", directive-name, [ group ], [ block ];
directive-name
  = directive-name-char - digit, { directive-name-char };
directive-name-char
  = "_" | digit | ? ASCII alphabetic character ?;
}

\h4{Directive names}

A \dfn{directive name} selects a specific directive to be processed.
The name begins with a \cowdoc_cp(0x5C) character,
followed by a sequence of ASCII alphanumeric characters or \cowdoc_cp(0x5F).
However, the first character after \cowdoc_cp(0x5C) cannot be an ASCII digit.

\Btip{
You can use an empty block of content to "cut a name short":
\cowblock{
Thisisavery\\wbr{}longword.
}
Doing so is equivalent to writing
\cowdoc_c{\\wbr} and \cowdoc_c{longword} immediately following one another.
}

\h4{Directive arguments}

Grammatically, the arguments are a \gterm{group},
which is constructed as follows:

\codeblock(ebnf){
group
  = "(", blank, [ group-member-list ], blank, ")";
group-member-list
  = group-member,
    { blank, ",", blank, group-member },
    blank, [ "," ];
group-member
  = member-name, blank, "=", blank, member-value
  | member-value
  | "...";
}

\dfn{Directive arguments} can be
\dfn{positional arguments},
\dfn{named arguments}, or
\dfn{ellipses}.
Arguments are separated by commas.
Unlike in the surrounding markup,
whitespace and comments surrounding directive arguments (i.e. \gterm{blank}) are ignored.

\Bex{
Often, arguments are converted to HTML attributes.
\cowblock{
\\b(id = abc){Bold text.}
}
Generated HTML:
\htmlblock{
<b id=abc>Bold text.</b>
}
}

\h5{Named arguments}

A \dfn{named argument} is a \gterm{group-member} of the form
\cowdoc_c{\cowel_highlight_phantom{\\d\N{LEFT PARENTHESIS}}name = value},
where spaces anywhere around \cowdoc_attr{name} and \cowdoc_c{value} are ignored.
Named arguments are matched to directive parameters before any positional arguments,
meaning that positional arguments fill the remaining unmatched arguments.

Argument names can consist of any character, except
ASCII control characters,
U+0020\c{nbsp}SPACE,
\cowdoc_cp(0x22),
\cowdoc_cp(0x27),
\cowdoc_cp(0x2C),
\cowdoc_cp(0x2F),
\cowdoc_cp(0x3D),
\cowdoc_cp(0x3E),
\cowdoc_cp(0x5B),
\cowdoc_cp(0x5C),
\cowdoc_cp(0x5D),
\cowdoc_cp(0x7B),
\cowdoc_cp(0x7D),
and noncharacters.

\Btip{
If you want to provide a positional argument that is \cowdoc_c{name = value} instead,
you can do so by writing:
\cowblock{\literally{
\: "name = value" as a positional argument
\xyz("name = value")
\: named argument with name "name" and value "value"
\xyz(name = value)
}}
Only the literal \cowdoc_c{=} character can be used for named arguments,
not its escaped variant \cowdoc_c{\\=}.
}

Grammatically, a \gterm{member-name} is constructed as follows:

\codeblock(ebnf){
member-name
  = member-name-char, { member-name-char };
member-name-char
  = ? HTML attribute name ? - ("\" | "(" | ")" | "{", "}" | ",");
}

\h5{Positional arguments}

A \dfn{positional argument} is a \gterm{group-member} of the form
\gterm{member-value}.

Positional arguments are content just like any other content,
except that an unbalanced closing \cowdoc_cp(0x5D) or a \cowdoc_cp(0x2C)
ends the content.

\h5{Ellipses}

An \dfn{ellipsis argument} is a \gterm{group-member}
spelled \ellipsis.
Ellipsis arguments are placeholders which expand to arguments provided to a surrounding macro.
See also \ref("#dir-cowel_macro") and \ref("#dir-cowel_put").

\Bex{
COWEL markup:
\cowblock{\literally{
\: Define a macro for generating <div> elements
\cowel_macro(div){\cowel_html_element(div, attr = (...)){\cowel_put}}

\div(id = abc){inner text}
}}
Generated HTML:
\htmlblock{
<div id=abc>inner text</div>
}
}

Specifically, any positional argument which begins with \ellipsis
(ignoring leading whitespace and comments)
is considered an ellipsis.
The text \tt{...} is not considered an ellipsis if it appears anywhere else
or has preceding content within an argument.

An error is raised if an ellipsis is used as an argument outside of a macro expansion.

\Bex{
\cowblock{\literally{
\m("...") \: OK, providing string "...", not an ellipsis
\m(...)   \: error: ellipsis is not expanded from a macro
}}
}

\h5{Groups}

Groups make it possible to group any of the aforementioned constructs.
Groups begin with \code(cowel){\cowel_highlight_phantom{\\d}\N{LEFT PARENTHESIS}}
and end with \code(cowel){\cowel_highlight_phantom{\\d\N{LEFT PARENTHESIS}}\N{RIGHT PARENTHESIS}}.
They can appear both in positional and in named arguments.

\Bex{
\codeblock(cowel){\literally{
\d((x), (), (y,))    \: groups as positional arguments
\d(n = (x, y))       \: group as named argument
\d(((())))           \: nested empty groups
}}
}

\Bwarn{
In the future, parentheses surrounding a single positional argument
will be treated as (ignored) parentheses around an expression,
like in typical programming languages.

For a group containing a single positional member,
\cowdoc_c{(x,)} may also be used.
That is, the trailing comma can only be used in a group,
not in an expression,
so it acts as a disambiguator.
}

\h4{Directive content}

The \dfn{directive content} is the primary input to a directive.
It is delimited by a '\tt{\{}' and ends with a \em{matching} closing '\tt{\}}'.
This means that you can have opening and closing braces inside text,
but they need to be balanced.

\Bex{
COWEL markup:
\cowblock{
\\b{Bold text { with braces }.}
}
Generated HTML:
\htmlblock{
<b>Bold text { with braces }.</b>
}
}

Escape sequences don't participate in this "brace matching",
so they can be used to literally produce a brace character.
\Bex{
COWEL markup:
\cowblock{
\\b{Bold text \\\U(0x7B) with brace.}
}
Generated HTML:
\htmlblock{
<b>Bold text \U(0x7B) with brace.</b>
}
}

Unlike in the directive arguments,
whitespace is not trimmed.
\Bex{
COWEL markup:
\cowblock{
\\b{bold} \\i{ italic }
}
Generated HTML:
\htmlblock{
<b>bold</b> <i> italic </i>
}
}

\Bnote{
Only one such block of content can be provided, unlike in TeX,
which has a similar syntax,
but permits multiple blocks. Each block is separated by a pair of braces.
}

\h3{Literals}

Inside scripting contexts such as in directive arguments,
a \gterm{primary-value} may appear.
A \gterm{primary-value} represents a value of a basic type (\ref("#types-intro")).

\codeblock(ebnf){
primary-value
  = unit-literal
  | null-literal
  | bool-literal
  | int-literal
  | float-literal
  | unquoted-string
  | quoted-string
  | block
  | group;
}

Some literals are simply keywords:

\ul{
  \li{
    The literal \cowdoc_c{unit} represents the value of type \cowdoc_type{unit}
    (\ref("#type-unit")).
  }
  \li{
    The literal \cowdoc_c{null} represents the value of type \cowdoc_type{null}
    (\ref("#type-null")).
  }
  \li{
    The literals \cowdoc_c{true} and \cowdoc_c{false} represent values of type \cowdoc_type{bool}
    (\ref("#type-bool")).
  }
}

\h4(id=int-literal){\gterm{int-literal} \N{EM DASH} Integer literal}

\codeblock(ebnf){
int-literal
  = binary-int-literal
  | octal-int-literal
  | decimal-int-literal
  | hexadecimal-int-literal;

binary-int-literal
  = [ "-" ], "0b", binary-digit, { binary-digit };
octal-int-literal
  = [ "-" ], "0o", octal-digit, { octal-digit };
decimal-int-literal
  = [ "-" ], digit, { digit };
hexadecimal-int-literal
  = [ "-" ], "0x", hexadecimal-digit, { hexadecimal-digit };

binary-digit
  = "0" | "1";
digit
  = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
octal-digit
  = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
hexadecimal-digit
  = digit
  | "A" | "B" | "C" | "D" | "E" | "F"
  | "a" | "b" | "c" | "d" | "e" | "f";
}

An \gterm{int-literal} represents a value of type \cowdoc_type{int}
(\ref("#type-int")).

The \dfn{base} \math{\mi{B}} of a \gterm{int-literal} is
\ul{
  \li{\math{\mn{2}} for a \gterm{binary-int-literal},}
  \li{\math{\mn{8}} for an \gterm{octal-int-literal},}
  \li{\math{\mn{10}} for an \gterm{decimal-int-literal}, and}
  \li{\math{\mn{16}} for an \gterm{hexadecimal-int-literal}.}
}
The value is of an \gterm{int-literal} in base \math{\mi{B}}
is determined by interpreting each digit from left to right
as decimal digits of a base-\math{\mi{B}} integer,
from most significant to least significant.
The \gterm{hexadecimal-digit}s \tt{a..f} and \tt{A..F} both represent
digits of value \math{\mn{10}}..\math{\mn{15}}.

Leading zeros are ignored.
The value is negative if the leading \cowdoc_cp(0x2D) is present.

\Bex{
The \gterm{int-literal} \cowdoc_c{-0123} represents the integer value
\math{\mrow{\mo(form=prefix){−}\mn{123}}}.

The \gterm{binary-int-literal} \cowdoc_c{0b11111111},
the \gterm{octal-int-literal} \cowdoc_c{0o377},
the \gterm{decimal-int-literal} \cowdoc_c{255}, and
the \gterm{hexadecimal-int-literal} \cowdoc_c{0xff}
all represent the value \math{\mn{255}}.
}

\h4(id=float-literal){\gterm{float-literal} \N{EM DASH} Floating-point literal}

\codeblock(ebnf){
float-literal
  = [ "-" ], "infinity"
  | decimal-float-literal;
decimal-float-literal
  = [ "-" ], digit, { digit }, ".", { digit }, [ exponent ]
  | [ "-" ], ".", digit, { digit }, [ exponent ]
  | [ "-" ], digit, { digit }, exponent;
exponent
  = ("e" | "E"), [ "+" | "-" ], digit, { digit };
}

A \gterm{float-literal} represents a value of type \cowdoc_type{float}
(\ref("#type-float")).

The value of '\tt{-infinity}' is negative infinity, and
the value of '\tt{infinity}' is positive infinity.

A \gterm{decimal-float-literal} consists of several parts:
\ul{
  \li{
    An \dfn{integral part}, either matching a \gterm{int-literal}
    or consisting of only a leading \cowdoc_cp(0x2D),
    which is equivalent to '\tt{-0}'.
  }
  \li{
    The radix point \cowdoc_cp(0x2E).
  }
  \li{
    A \dfn{fractional part} consisting of \gterm{digit}s following the radix point.
    An absent fractional part is equivalent to '\tt{0}'.
  }
  \li{
    An \gterm{exponent}.
  }
}

The value of a \gterm{decimal-float-literal} is determined as follows:

\ol{
  \li{
    Let \math{\mi{s}} be -1 if the leading \cowdoc_cp(0x2D) is present,
    otherwise 1;
    let \math{\mi{k}} be the integer value of the integral part
    (determined as for a \gterm{int-literal});
    let \math{\mi{f}} be the the integer value of the fractional part;
    let \math{\mi{p}} be the amount of digits including leading zeros of the fractional part;
    let \math{\mi{e}} be the integer value of the exponent.
  }
  \li{
    Let the \dfn{scaled value} of the \gterm{decimal-float-literal} be
    \mathblock{\mrow{
      \mi{s}
      \mo{×}
      \mo{\N{LEFT PARENTHESIS}}
      \mi{k}
      \mo{+}
      \mfrac{\mi{f}\msup{\mn{10}\mi{p}}}
      \mo{\N{RIGHT PARENTHESIS}}
      \mo{×}
      \msup{\mn{10}\mi{e}}
    }}
  }
  \li{
    The value of the \gterm{decimal-float-literal} is the scaled value,
    rounded using the roundTiesToEven rounding direction
    as specified in IEEE-754.
  }
}

\Bex{
\ul{
  \li{\cowdoc_c{1.0} exactly represents the value 1.0.}
  \li{\cowdoc_c{.1} is rounded to a value nearest to 0.1.}
  \li{\cowdoc_c{1e1000000} is rounded to positive infinity.}
  \li{\cowdoc_c{-1e1000000} is rounded to negative infinity.}
  \li{\cowdoc_c{1e-1000000} is rounded to positive zero.}
  \li{\cowdoc_c{-1e-1000000} is rounded to negative zero.}
  \li{\cowdoc_c{-0.0} exactly represents a negative zero.}
}
}
