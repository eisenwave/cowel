#include <algorithm>

#include "cowel/util/case_transform.hpp"

using namespace std::string_view_literals;

namespace cowel {
namespace {

struct Case_Transform_Simple_Entry {
    char32_t key;
    char32_t value;
};

constexpr Case_Transform_Simple_Entry simple_upper_table[] {
#include "case_transform_simple_upper_autogenerated.cpp.txt"
};

constexpr Case_Transform_Simple_Entry simple_lower_table[] {
#include "case_transform_simple_lower_autogenerated.cpp.txt"
};

static_assert(std::ranges::is_sorted(simple_upper_table, {}, &Case_Transform_Simple_Entry::key));
static_assert(std::ranges::is_sorted(simple_lower_table, {}, &Case_Transform_Simple_Entry::key));

const Case_Transform_Simple_Entry* simple_to_upper_impl(char32_t c)
{
    const Case_Transform_Simple_Entry* const result
        = std::ranges::lower_bound(simple_upper_table, c, {}, &Case_Transform_Simple_Entry::key);
    return result == std::ranges::end(simple_upper_table) || result->key != c //
        ? nullptr
        : result;
}

constexpr const Case_Transform_Simple_Entry* simple_to_lower_impl(char32_t c)
{
    const Case_Transform_Simple_Entry* const result
        = std::ranges::lower_bound(simple_lower_table, c, {}, &Case_Transform_Simple_Entry::key);
    return result == std::ranges::end(simple_lower_table) || result->key != c //
        ? nullptr
        : result;
}

struct Case_Transform_Special_Entry {
    char32_t key;
    std::u32string_view value;
};

constexpr Case_Transform_Special_Entry special_upper_table[] {
#include "case_transform_special_upper_autogenerated.cpp.txt"
};

constexpr Case_Transform_Special_Entry special_lower_table[] {
#include "case_transform_special_lower_autogenerated.cpp.txt"
};

static_assert(std::ranges::is_sorted(special_upper_table, {}, &Case_Transform_Special_Entry::key));
static_assert(std::ranges::is_sorted(special_lower_table, {}, &Case_Transform_Special_Entry::key));

const Case_Transform_Special_Entry* special_to_upper_impl(char32_t c)
{
    const Case_Transform_Special_Entry* const result
        = std::ranges::lower_bound(special_upper_table, c, {}, &Case_Transform_Special_Entry::key);
    return result == std::ranges::end(special_upper_table) || result->key != c //
        ? nullptr
        : result;
}

const Case_Transform_Special_Entry* special_to_lower_impl(char32_t c)
{
    static_assert(std::size(special_lower_table) == 1);
    return special_lower_table->key == c ? special_lower_table : nullptr;
}

} // namespace

char32_t simple_to_upper(char32_t c)
{
    const auto* const result = simple_to_upper_impl(c);
    return result ? result->value : c;
}

char32_t simple_to_lower(char32_t c)
{
    const auto* const result = simple_to_lower_impl(c);
    return result ? result->value : c;
}

std::u32string_view unconditional_to_upper(char32_t c)
{
    if (const auto* const special = special_to_upper_impl(c); special) {
        return special->value;
    }
    if (const auto* const simple = simple_to_upper_impl(c); simple) {
        return std::u32string_view { &simple->value, 1 };
    }
    return U""sv;
}

std::u32string_view unconditional_to_lower(char32_t c)
{
    if (const auto* const special = special_to_lower_impl(c); special) {
        return special->value;
    }
    if (const auto* const simple = simple_to_lower_impl(c); simple) {
        return std::u32string_view { &simple->value, 1 };
    }
    return U""sv;
}

} // namespace cowel
